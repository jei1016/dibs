@schema {id crate:dibs-queries@1, cli dibs}

// Queries for my-app ecommerce example.
// These are parsed by dibs-query-gen and generate Rust code + SQL.

AllProducts @query{
    from product
    where {deleted_at @null}
    order-by {created_at desc}
    select {id, handle, status, active}
}

ActiveProducts @query{
    from product
    where {status "published", active true, deleted_at @null}
    order-by {created_at desc}
    limit 2
    select {id, handle, status}
}

ProductByHandle @query{
    params {handle @string}
    from product
    where {handle $handle, deleted_at @null}
    first true
    select {id, handle, status, active}
}

SearchProducts @query{
    params {q @string}
    from product
    where {handle @ilike($q), deleted_at @null}
    order-by {handle asc}
    limit 50
    select {id, handle, status}
}
// Paginated query with limit/offset parameters

ProductsPaginated @query{
    params {page_size @int, page_offset @int}
    from product
    where {deleted_at @null}
    order-by {handle asc}
    limit $page_size
    offset $page_offset
    select {id, handle, status, active}
}
// Query with JOIN - returns product with its first translation

ProductWithTranslation @query{
    params {handle @string}
    from product
    where {handle $handle, deleted_at @null}
    first true
    select {
        id
        handle
        status
        translation @rel{
            from product_translation
            first true
            select {locale, title, description}
        }
    }
}

// ============================================================================
// Mutations
// ============================================================================

// Insert a new product

CreateProduct @insert{
    params {handle @string, status @string}
    into product
    values {handle $handle, status $status, created_at @now}
    returning {id, handle, status}
}

// Insert a product with default status

CreateProductWithDefaults @insert{
    params {handle @string}
    into product
    values {handle $handle, status @default, created_at @now}
    returning {id, handle, status}
}

// Upsert a product - insert or update on conflict

UpsertProduct @upsert{
    params {handle @string, status @string}
    into product
    on-conflict {
        target {handle}
        update {status, updated_at @now}
    }
    values {handle $handle, status $status, created_at @now}
    returning {id, handle, status}
}

// Update a product by handle

UpdateProductStatus @update{
    params {handle @string, status @string}
    table product
    set {status $status, updated_at @now}
    where {handle $handle}
    returning {id, handle, status}
}

// Soft delete a product

SoftDeleteProduct @update{
    params {handle @string}
    table product
    set {deleted_at @now}
    where {handle $handle}
    returning {id, handle}
}

// Hard delete a product (use with caution!)

DeleteProduct @delete{
    params {id @int}
    from product
    where {id $id}
    returning {id, handle}
}
