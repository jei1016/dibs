//! Rust code generation from query AST.
//!
//! TODO: Replace manual string building with the `codegen` crate for cleaner code generation.

use crate::ast::*;
use crate::planner::PlannerSchema;
use crate::sql::{generate_simple_sql, generate_sql_with_joins};
use std::collections::HashMap;

/// Generated Rust code for a query file.
#[derive(Debug, Clone)]
pub struct GeneratedCode {
    /// Full Rust source code.
    pub code: String,
}

/// Schema information for code generation.
///
/// This provides type information for columns, allowing the codegen
/// to emit correctly-typed result structs.
#[derive(Debug, Clone, Default)]
pub struct SchemaInfo {
    /// Map of table name -> column info.
    pub tables: HashMap<String, TableInfo>,
}

/// Information about a single table.
#[derive(Debug, Clone, Default)]
pub struct TableInfo {
    /// Map of column name -> Rust type string.
    pub columns: HashMap<String, ColumnInfo>,
}

/// Information about a single column.
#[derive(Debug, Clone)]
pub struct ColumnInfo {
    /// Rust type name (e.g., "i64", "String", "bool").
    pub rust_type: String,
    /// Whether the column is nullable (`Option<T>`).
    pub nullable: bool,
}

impl SchemaInfo {
    /// Create a new empty schema.
    pub fn new() -> Self {
        Self::default()
    }

    /// Look up the Rust type for a column.
    pub fn column_type(&self, table: &str, column: &str) -> Option<String> {
        let table_info = self.tables.get(table)?;
        let col_info = table_info.columns.get(column)?;
        if col_info.nullable {
            Some(format!("Option<{}>", col_info.rust_type))
        } else {
            Some(col_info.rust_type.clone())
        }
    }
}

/// Context for code generation.
struct CodegenContext<'a> {
    schema: &'a SchemaInfo,
    planner_schema: Option<&'a PlannerSchema>,
}

/// Generate Rust code for a query file.
pub fn generate_rust_code(file: &QueryFile) -> GeneratedCode {
    generate_rust_code_with_schema(file, &SchemaInfo::default())
}

/// Generate Rust code for a query file with schema information.
pub fn generate_rust_code_with_schema(file: &QueryFile, schema: &SchemaInfo) -> GeneratedCode {
    generate_rust_code_with_planner(file, schema, None)
}

/// Generate Rust code for a query file with full schema and planner info.
///
/// When `planner_schema` is provided, queries with relations will generate
/// JOINs and proper result assembly code.
pub fn generate_rust_code_with_planner(
    file: &QueryFile,
    schema: &SchemaInfo,
    planner_schema: Option<&PlannerSchema>,
) -> GeneratedCode {
    let ctx = CodegenContext {
        schema,
        planner_schema,
    };
    let mut code = String::new();

    // Imports
    code.push_str("// Generated by dibs-query-gen. Do not edit.\n\n");
    code.push_str("use dibs_runtime::prelude::*;\n");
    code.push_str("use dibs_runtime::tokio_postgres;\n\n");

    for query in &file.queries {
        generate_query_code(&ctx, query, &mut code);
    }

    GeneratedCode { code }
}

fn generate_query_code(ctx: &CodegenContext, query: &Query, code: &mut String) {
    // Generate result struct
    let struct_name = format!("{}Result", query.name);
    generate_result_struct(ctx, query, &struct_name, &query.from, &query.select, code);

    code.push('\n');

    // Generate query function
    generate_query_function(ctx, query, &struct_name, code);

    code.push('\n');
}

fn generate_result_struct(
    ctx: &CodegenContext,
    query: &Query,
    struct_name: &str,
    table: &str,
    fields: &[Field],
    code: &mut String,
) {
    code.push_str("#[derive(Debug, Clone, Facet)]\n");
    code.push_str("#[facet(crate = dibs_runtime::facet)]\n");
    code.push_str(&format!("pub struct {} {{\n", struct_name));

    if query.is_raw() {
        // Raw SQL - use returns declaration
        for ret in &query.returns {
            let rust_ty = param_type_to_rust(&ret.ty);
            code.push_str(&format!("    pub {}: {},\n", ret.name, rust_ty));
        }
    } else {
        // Regular query - use select fields
        for field in fields {
            match field {
                Field::Column { name, .. } => {
                    // Look up type from schema, fall back to String
                    let rust_ty = ctx
                        .schema
                        .column_type(table, name)
                        .unwrap_or_else(|| "String".to_string());
                    code.push_str(&format!("    pub {}: {},\n", name, rust_ty));
                }
                Field::Relation {
                    name,
                    first,
                    select,
                    from,
                    ..
                } => {
                    // Nested struct for relation
                    let nested_name = to_pascal_case(name);
                    let ty = if *first {
                        format!("Option<{}>", nested_name)
                    } else {
                        format!("Vec<{}>", nested_name)
                    };
                    code.push_str(&format!("    pub {}: {},\n", name, ty));
                    // We'll generate nested struct after the parent
                    let _ = (select, from);
                }
                Field::Count { name, .. } => {
                    code.push_str(&format!("    pub {}: i64,\n", name));
                }
            }
        }
    }

    code.push_str("}\n");

    // Generate nested structs for relations
    if !query.is_raw() {
        for field in fields {
            if let Field::Relation {
                name, select, from, ..
            } = field
            {
                let nested_name = to_pascal_case(name);
                // Use explicit from table, or infer from relation name
                let rel_table = from.as_deref().unwrap_or(name);
                code.push('\n');
                code.push_str("#[derive(Debug, Clone, Facet)]\n");
                code.push_str("#[facet(crate = dibs_runtime::facet)]\n");
                code.push_str(&format!("pub struct {} {{\n", nested_name));
                for f in select {
                    if let Field::Column { name, .. } = f {
                        let rust_ty = ctx
                            .schema
                            .column_type(rel_table, name)
                            .unwrap_or_else(|| "String".to_string());
                        code.push_str(&format!("    pub {}: {},\n", name, rust_ty));
                    }
                }
                code.push_str("}\n");
            }
        }
    }
}

fn generate_query_function(
    ctx: &CodegenContext,
    query: &Query,
    struct_name: &str,
    code: &mut String,
) {
    let fn_name = to_snake_case(&query.name);

    // Function signature
    code.push_str(&format!("pub async fn {}<C>(\n", fn_name));
    code.push_str("    client: &C,\n");

    for param in &query.params {
        let rust_ty = param_type_to_rust(&param.ty);
        code.push_str(&format!("    {}: &{},\n", param.name, rust_ty));
    }

    let return_ty = if query.first {
        format!("Result<Option<{}>, QueryError>", struct_name)
    } else {
        format!("Result<Vec<{}>, QueryError>", struct_name)
    };

    code.push_str(&format!(
        ") -> {}\nwhere\n    C: tokio_postgres::GenericClient,\n{{\n",
        return_ty
    ));

    // Function body
    if let Some(raw_sql) = &query.raw_sql {
        // Raw SQL query
        generate_raw_query_body(query, raw_sql, code);
    } else {
        // Check if query has relations and we have planner schema
        let has_relations = query
            .select
            .iter()
            .any(|f| matches!(f, Field::Relation { .. }));

        if has_relations && ctx.planner_schema.is_some() {
            // Generate JOIN-based query with result assembly
            generate_join_query_body(ctx, query, struct_name, code);
        } else {
            // Simple query - no JOINs needed
            generate_simple_query_body(query, code);
        }
    }

    code.push_str("}\n");
}

/// Generate query body for queries with JOINs.
///
/// This generates:
/// 1. The SQL with JOINs
/// 2. A flat row struct matching the JOIN result columns
/// 3. Assembly code to convert flat rows to nested result structs
fn generate_join_query_body(
    ctx: &CodegenContext,
    query: &Query,
    struct_name: &str,
    code: &mut String,
) {
    let planner_schema = ctx.planner_schema.unwrap();

    // Generate SQL with JOINs
    let generated = match generate_sql_with_joins(query, planner_schema) {
        Ok(g) => g,
        Err(e) => {
            // Fall back to simple SQL on planning error
            code.push_str(&format!("    // Warning: JOIN planning failed: {}\n", e));
            generate_simple_query_body(query, code);
            return;
        }
    };

    let plan = generated.plan.as_ref().unwrap();

    code.push_str(&format!(
        "    const SQL: &str = r#\"{}\"#;\n\n",
        generated.sql
    ));

    // Build params array
    let params: Vec<_> = generated
        .param_order
        .iter()
        .filter(|p| !p.starts_with("__literal_"))
        .collect();

    if params.is_empty() {
        code.push_str("    let rows = client.query(SQL, &[]).await?;\n\n");
    } else {
        code.push_str("    let rows = client.query(SQL, &[");
        for (i, param_name) in params.iter().enumerate() {
            if i > 0 {
                code.push_str(", ");
            }
            code.push_str(param_name);
        }
        code.push_str("]).await?;\n\n");
    }

    // Generate assembly code
    code.push_str("    // Assemble flat rows into nested structs\n");
    code.push_str("    let results: Result<Vec<_>, QueryError> = rows.iter().map(|row| {\n");

    // Extract base table columns
    for field in &query.select {
        if let Field::Column { name, .. } = field {
            let rust_ty = ctx
                .schema
                .column_type(&query.from, name)
                .unwrap_or_else(|| "String".to_string());
            code.push_str(&format!(
                "        let {}: {} = row.get(\"{}\");\n",
                name, rust_ty, name
            ));
        }
    }

    // Extract relation columns and build nested structs
    for field in &query.select {
        if let Field::Relation {
            name,
            first,
            select,
            from,
            ..
        } = field
        {
            let rel_table = from.as_deref().unwrap_or(name);
            let nested_name = to_pascal_case(name);

            // Extract each column from the relation
            for f in select {
                if let Field::Column { name: col_name, .. } = f {
                    let rust_ty = ctx
                        .schema
                        .column_type(rel_table, col_name)
                        .unwrap_or_else(|| "String".to_string());
                    let alias = format!("{}_{}", name, col_name);
                    // LEFT JOIN columns are always nullable
                    // If the type is already Option<T>, don't wrap it again
                    let wrapped_ty = if rust_ty.starts_with("Option<") {
                        rust_ty.clone()
                    } else {
                        format!("Option<{}>", rust_ty)
                    };
                    code.push_str(&format!(
                        "        let {}: {} = row.get(\"{}\");\n",
                        alias, wrapped_ty, alias
                    ));
                }
            }

            // Build the nested struct (Option for first=true, Vec for first=false)
            if *first {
                // For first=true, check if the first column is Some
                let first_col = select
                    .iter()
                    .find_map(|f| {
                        if let Field::Column { name, .. } = f {
                            Some(name.clone())
                        } else {
                            None
                        }
                    })
                    .unwrap_or_default();
                let first_alias = format!("{}_{}", name, first_col);

                // Use .map() to avoid clippy::manual_map warning
                code.push_str(&format!(
                    "        let {} = {}.map(|{}_val| {} {{\n",
                    name, first_alias, first_alias, nested_name
                ));
                for f in select {
                    if let Field::Column { name: col_name, .. } = f {
                        let alias = format!("{}_{}", name, col_name);
                        // Check if the column is already nullable - if so, don't unwrap
                        let rust_ty = ctx
                            .schema
                            .column_type(rel_table, col_name)
                            .unwrap_or_else(|| "String".to_string());
                        let value_expr = if rust_ty.starts_with("Option<") {
                            alias.clone() // Already Option, pass directly
                        } else if alias == first_alias {
                            // Use the captured value from map closure
                            format!("{}_val", first_alias)
                        } else {
                            format!("{}.unwrap()", alias) // Unwrap the JOIN's Option wrapper
                        };
                        code.push_str(&format!("            {}: {},\n", col_name, value_expr));
                    }
                }
                code.push_str("        });\n");
            } else {
                // For first=false (Vec), this is more complex - need to group by parent ID
                // For now, just create a single-element vec if present
                let first_col = select
                    .iter()
                    .find_map(|f| {
                        if let Field::Column { name, .. } = f {
                            Some(name.clone())
                        } else {
                            None
                        }
                    })
                    .unwrap_or_default();
                let first_alias = format!("{}_{}", name, first_col);

                // Use if let Some() pattern to avoid unnecessary_unwrap clippy warning
                code.push_str(&format!(
                    "        let {} = if let Some({}_val) = {} {{\n",
                    name, first_alias, first_alias
                ));
                code.push_str(&format!("            vec![{} {{\n", nested_name));
                for f in select {
                    if let Field::Column { name: col_name, .. } = f {
                        let alias = format!("{}_{}", name, col_name);
                        // Check if the column is already nullable - if so, don't unwrap
                        let rust_ty = ctx
                            .schema
                            .column_type(rel_table, col_name)
                            .unwrap_or_else(|| "String".to_string());
                        let value_expr = if rust_ty.starts_with("Option<") {
                            alias.clone() // Already Option, pass directly
                        } else if alias == first_alias {
                            // Use the captured value from if let
                            format!("{}_val", first_alias)
                        } else {
                            format!("{}.unwrap()", alias) // Unwrap the JOIN's Option wrapper
                        };
                        code.push_str(&format!("                {}: {},\n", col_name, value_expr));
                    }
                }
                code.push_str("            }]\n");
                code.push_str("        } else {\n");
                code.push_str("            vec![]\n");
                code.push_str("        };\n");
            }
        }
    }

    // Build the result struct
    code.push_str(&format!("        Ok({} {{\n", struct_name));
    for field in &query.select {
        match field {
            Field::Column { name, .. } | Field::Relation { name, .. } => {
                code.push_str(&format!("            {},\n", name));
            }
            Field::Count { name, .. } => {
                code.push_str(&format!("            {}: 0, // TODO: COUNT\n", name));
            }
        }
    }
    code.push_str("        })\n");
    code.push_str("    }).collect();\n\n");

    // Return based on first flag
    if query.first {
        code.push_str("    Ok(results?.into_iter().next())\n");
    } else {
        code.push_str("    results\n");
    }

    // Suppress unused warning for plan
    let _ = plan;
}

fn generate_simple_query_body(query: &Query, code: &mut String) {
    let generated = generate_simple_sql(query);

    code.push_str(&format!(
        "    const SQL: &str = r#\"{}\"#;\n\n",
        generated.sql
    ));

    // Build params array
    let params: Vec<_> = generated
        .param_order
        .iter()
        .filter(|p| !p.starts_with("__literal_"))
        .collect();

    if params.is_empty() {
        code.push_str("    let rows = client.query(SQL, &[]).await?;\n");
    } else {
        code.push_str("    let rows = client.query(SQL, &[");
        for (i, param_name) in params.iter().enumerate() {
            if i > 0 {
                code.push_str(", ");
            }
            code.push_str(param_name);
        }
        code.push_str("]).await?;\n");
    }

    // Convert rows to structs
    if query.first {
        code.push_str("    match rows.into_iter().next() {\n");
        code.push_str("        Some(row) => Ok(Some(from_row(&row)?)),\n");
        code.push_str("        None => Ok(None),\n");
        code.push_str("    }\n");
    } else {
        code.push_str("    rows.iter().map(|row| Ok(from_row(row)?)).collect()\n");
    }
}

fn generate_raw_query_body(query: &Query, raw_sql: &str, code: &mut String) {
    // Clean up the raw SQL - remove leading/trailing whitespace per line
    let cleaned: String = raw_sql
        .lines()
        .map(|l| l.trim())
        .collect::<Vec<_>>()
        .join("\n");

    code.push_str(&format!(
        "    const SQL: &str = r#\"{}\"#;\n\n",
        cleaned.trim()
    ));

    // Build params
    if query.params.is_empty() {
        code.push_str("    let rows = client.query(SQL, &[]).await?;\n");
    } else {
        code.push_str("    let rows = client.query(SQL, &[");
        for (i, param) in query.params.iter().enumerate() {
            if i > 0 {
                code.push_str(", ");
            }
            code.push_str(&param.name);
        }
        code.push_str("]).await?;\n");
    }

    // Convert rows to structs
    if query.first {
        code.push_str("    match rows.into_iter().next() {\n");
        code.push_str("        Some(row) => Ok(Some(from_row(&row)?)),\n");
        code.push_str("        None => Ok(None),\n");
        code.push_str("    }\n");
    } else {
        code.push_str("    rows.iter().map(|row| Ok(from_row(row)?)).collect()\n");
    }
}

fn param_type_to_rust(ty: &ParamType) -> String {
    match ty {
        ParamType::String => "String".to_string(),
        ParamType::Int => "i64".to_string(),
        ParamType::Bool => "bool".to_string(),
        ParamType::Uuid => "Uuid".to_string(),
        ParamType::Decimal => "Decimal".to_string(),
        ParamType::Timestamp => "Timestamp".to_string(),
        ParamType::Optional(inner) => format!("Option<{}>", param_type_to_rust(inner)),
    }
}

fn to_pascal_case(s: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = true;

    for c in s.chars() {
        if c == '_' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }

    result
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();

    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parse::parse_query_file;

    #[test]
    fn test_generate_simple_query() {
        let source = r#"
AllProducts @query{
  from product
  select{ id, handle, status }
}
"#;
        let file = parse_query_file(source).unwrap();
        let code = generate_rust_code(&file);

        assert!(code.code.contains("pub struct AllProductsResult"));
        assert!(code.code.contains("pub async fn all_products"));
        assert!(code.code.contains("pub id: String"));
        assert!(code.code.contains("pub handle: String"));
        assert!(code.code.contains("#[derive(Debug, Clone, Facet)]"));
    }

    #[test]
    fn test_generate_query_with_params() {
        let source = r#"
ProductByHandle @query{
  params{ handle @string }
  from product
  where{ handle $handle }
  first true
  select{ id, handle }
}
"#;
        let file = parse_query_file(source).unwrap();
        let code = generate_rust_code(&file);

        assert!(code.code.contains("handle: &String"));
        assert!(code.code.contains("from_row"));
        assert!(code.code.contains("Ok(None)"));
    }

    #[test]
    fn test_generate_query_with_relation() {
        let source = r#"
ProductListing @query{
  from product
  select{
    id
    translation @rel{
      first true
      select{ title, description }
    }
  }
}
"#;
        let file = parse_query_file(source).unwrap();
        let code = generate_rust_code(&file);

        assert!(code.code.contains("pub translation: Option<Translation>"));
        assert!(code.code.contains("pub struct Translation"));
        assert!(code.code.contains("pub title: String"));
    }

    #[test]
    fn test_generate_raw_sql_query() {
        let source = r#"
TrendingProducts @query{
  params{
    locale @string
    days @int
  }
  sql <<SQL
    SELECT id, title FROM products WHERE locale = $1
  SQL
  returns{
    id @int
    title @string
  }
}
"#;
        let file = parse_query_file(source).unwrap();
        let code = generate_rust_code(&file);

        assert!(code.code.contains("locale: &String"));
        assert!(code.code.contains("days: &i64"));
        assert!(code.code.contains("pub id: i64"));
        assert!(code.code.contains("pub title: String"));
        assert!(code.code.contains("SELECT id, title FROM products"));
    }

    #[test]
    fn test_snake_case() {
        assert_eq!(to_snake_case("ProductListing"), "product_listing");
        assert_eq!(to_snake_case("AllProducts"), "all_products");
        assert_eq!(to_snake_case("ID"), "i_d");
    }

    #[test]
    fn test_pascal_case() {
        assert_eq!(to_pascal_case("translation"), "Translation");
        assert_eq!(to_pascal_case("product_variant"), "ProductVariant");
    }

    #[test]
    fn test_generate_join_query() {
        use crate::planner::{PlannerForeignKey, PlannerSchema, PlannerTable};

        let source = r#"
ProductWithTranslation @query{
  params{ handle @string }
  from product
  where{ handle $handle }
  first true
  select{
    id
    handle
    translation @rel{
      from product_translation
      first true
      select{ title, description }
    }
  }
}
"#;
        let file = parse_query_file(source).unwrap();

        // Build schema info (for types)
        let mut schema = SchemaInfo::default();
        let mut product_cols = HashMap::new();
        product_cols.insert(
            "id".to_string(),
            ColumnInfo {
                rust_type: "i64".to_string(),
                nullable: false,
            },
        );
        product_cols.insert(
            "handle".to_string(),
            ColumnInfo {
                rust_type: "String".to_string(),
                nullable: false,
            },
        );
        schema.tables.insert(
            "product".to_string(),
            TableInfo {
                columns: product_cols,
            },
        );

        let mut translation_cols = HashMap::new();
        translation_cols.insert(
            "title".to_string(),
            ColumnInfo {
                rust_type: "String".to_string(),
                nullable: false,
            },
        );
        translation_cols.insert(
            "description".to_string(),
            ColumnInfo {
                rust_type: "String".to_string(),
                nullable: true,
            },
        );
        schema.tables.insert(
            "product_translation".to_string(),
            TableInfo {
                columns: translation_cols,
            },
        );

        // Build planner schema (for FK relationships)
        let mut planner_schema = PlannerSchema::default();
        planner_schema.tables.insert(
            "product".to_string(),
            PlannerTable {
                name: "product".to_string(),
                columns: vec!["id".to_string(), "handle".to_string()],
                foreign_keys: vec![],
            },
        );
        planner_schema.tables.insert(
            "product_translation".to_string(),
            PlannerTable {
                name: "product_translation".to_string(),
                columns: vec![
                    "id".to_string(),
                    "product_id".to_string(),
                    "title".to_string(),
                    "description".to_string(),
                ],
                foreign_keys: vec![PlannerForeignKey {
                    columns: vec!["product_id".to_string()],
                    references_table: "product".to_string(),
                    references_columns: vec!["id".to_string()],
                }],
            },
        );

        let code = generate_rust_code_with_planner(&file, &schema, Some(&planner_schema));

        // Check struct generation
        assert!(
            code.code
                .contains("pub struct ProductWithTranslationResult")
        );
        assert!(code.code.contains("pub id: i64"));
        assert!(code.code.contains("pub handle: String"));
        assert!(code.code.contains("pub translation: Option<Translation>"));
        assert!(code.code.contains("pub struct Translation"));

        // Check SQL generation with JOINs
        assert!(code.code.contains("LEFT JOIN"));
        assert!(code.code.contains("product_translation"));

        // Check assembly code generation
        assert!(code.code.contains("translation_title"));
        assert!(code.code.contains("translation_description"));
        assert!(
            code.code
                .contains(".map(|translation_title_val| Translation")
        );
        assert!(code.code.contains("title: translation_title_val"));
    }
}
