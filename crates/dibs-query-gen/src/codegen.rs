//! Rust code generation from query AST using the `codegen` crate.

use crate::ast::*;
use crate::planner::PlannerSchema;
use crate::sql::{GeneratedSql, generate_simple_sql, generate_sql_with_joins};
use codegen::{Block, Function, Scope, Struct};
use std::collections::HashMap;

/// Helper to generate a row.get() call using column index if available, with a comment.
fn row_get(column_name: &str, column_order: &HashMap<String, usize>) -> String {
    if let Some(&idx) = column_order.get(column_name) {
        format!("row.get({}) /* {} */", idx, column_name)
    } else {
        // Fallback to name-based access (shouldn't happen if column_order is complete)
        format!("row.get(\"{}\")", column_name)
    }
}

/// Helper to get just the column selector (index or quoted string) for use in row.get::<T>(...)
fn col_selector(column_name: &str, column_order: &HashMap<String, usize>) -> String {
    if let Some(&idx) = column_order.get(column_name) {
        format!("{} /* {} */", idx, column_name)
    } else {
        format!("\"{}\"", column_name)
    }
}

/// Generated Rust code for a query file.
#[derive(Debug, Clone)]
pub struct GeneratedCode {
    /// Full Rust source code.
    pub code: String,
}

/// Schema information for code generation.
///
/// This provides type information for columns, allowing the codegen
/// to emit correctly-typed result structs.
#[derive(Debug, Clone, Default)]
pub struct SchemaInfo {
    /// Map of table name -> column info.
    pub tables: HashMap<String, TableInfo>,
}

/// Information about a single table.
#[derive(Debug, Clone, Default)]
pub struct TableInfo {
    /// Map of column name -> Rust type string.
    pub columns: HashMap<String, ColumnInfo>,
}

/// Information about a single column.
#[derive(Debug, Clone)]
pub struct ColumnInfo {
    /// Rust type name (e.g., "i64", "String", "bool").
    pub rust_type: String,
    /// Whether the column is nullable (`Option<T>`).
    pub nullable: bool,
}

impl SchemaInfo {
    /// Create a new empty schema.
    pub fn new() -> Self {
        Self::default()
    }

    /// Look up the Rust type for a column.
    pub fn column_type(&self, table: &str, column: &str) -> Option<String> {
        let table_info = self.tables.get(table)?;
        let col_info = table_info.columns.get(column)?;
        if col_info.nullable {
            Some(format!("Option<{}>", col_info.rust_type))
        } else {
            Some(col_info.rust_type.clone())
        }
    }
}

/// Context for code generation.
struct CodegenContext<'a> {
    schema: &'a SchemaInfo,
    planner_schema: Option<&'a PlannerSchema>,
}

/// Generate Rust code for a query file.
pub fn generate_rust_code(file: &QueryFile) -> GeneratedCode {
    generate_rust_code_with_schema(file, &SchemaInfo::default())
}

/// Generate Rust code for a query file with schema information.
pub fn generate_rust_code_with_schema(file: &QueryFile, schema: &SchemaInfo) -> GeneratedCode {
    generate_rust_code_with_planner(file, schema, None)
}

/// Generate Rust code for a query file with full schema and planner info.
///
/// When `planner_schema` is provided, queries with relations will generate
/// JOINs and proper result assembly code.
pub fn generate_rust_code_with_planner(
    file: &QueryFile,
    schema: &SchemaInfo,
    planner_schema: Option<&PlannerSchema>,
) -> GeneratedCode {
    let ctx = CodegenContext {
        schema,
        planner_schema,
    };

    let mut scope = Scope::new();

    // Add file header as raw code
    scope.raw("// Generated by dibs-query-gen. Do not edit.");
    scope.raw("");

    // Imports
    scope.import("dibs_runtime::prelude", "*");
    scope.import("dibs_runtime", "tokio_postgres");

    for query in &file.queries {
        generate_query_code(&ctx, query, &mut scope);
    }

    for insert in &file.inserts {
        generate_insert_code(&ctx, insert, &mut scope);
    }

    for upsert in &file.upserts {
        generate_upsert_code(&ctx, upsert, &mut scope);
    }

    for update in &file.updates {
        generate_update_code(&ctx, update, &mut scope);
    }

    for delete in &file.deletes {
        generate_delete_code(&ctx, delete, &mut scope);
    }

    GeneratedCode {
        code: scope.to_string(),
    }
}

fn generate_query_code(ctx: &CodegenContext, query: &Query, scope: &mut Scope) {
    let struct_name = format!("{}Result", query.name);

    // Generate result struct(s)
    generate_result_struct(ctx, query, &struct_name, &query.from, &query.select, scope);

    // Generate query function
    generate_query_function(ctx, query, &struct_name, scope);
}

fn generate_result_struct(
    ctx: &CodegenContext,
    query: &Query,
    struct_name: &str,
    table: &str,
    fields: &[Field],
    scope: &mut Scope,
) {
    let mut st = Struct::new(struct_name);
    st.vis("pub");
    st.derive("Debug");
    st.derive("Clone");
    st.derive("Facet");
    st.attr("facet(crate = dibs_runtime::facet)");

    if query.is_raw() {
        // Raw SQL - use returns declaration
        for ret in &query.returns {
            let rust_ty = param_type_to_rust(&ret.ty);
            st.field(format!("pub {}", ret.name), &rust_ty);
        }
    } else {
        // Regular query - use select fields
        // Use query name as prefix for namespacing nested structs
        let parent_prefix = &query.name;
        for field in fields {
            match field {
                Field::Column { name, .. } => {
                    let rust_ty = ctx
                        .schema
                        .column_type(table, name)
                        .unwrap_or_else(|| "String".to_string());
                    st.field(format!("pub {}", name), &rust_ty);
                }
                Field::Relation { name, first, .. } => {
                    let nested_name = format!("{}{}", parent_prefix, to_pascal_case(name));
                    let ty = if *first {
                        format!("Option<{}>", nested_name)
                    } else {
                        format!("Vec<{}>", nested_name)
                    };
                    st.field(format!("pub {}", name), &ty);
                }
                Field::Count { name, .. } => {
                    st.field(format!("pub {}", name), "i64");
                }
            }
        }
    }

    scope.push_struct(st);

    // Generate nested structs for relations (recursively)
    if !query.is_raw() {
        generate_nested_structs(ctx, &query.name, fields, scope);
    }
}

/// Recursively generate structs for nested relations.
///
/// `parent_prefix` is used to namespace the struct names to avoid collisions
/// when multiple queries have relations with the same field name.
fn generate_nested_structs(
    ctx: &CodegenContext,
    parent_prefix: &str,
    fields: &[Field],
    scope: &mut Scope,
) {
    for field in fields {
        if let Field::Relation {
            name, select, from, ..
        } = field
        {
            let nested_name = format!("{}{}", parent_prefix, to_pascal_case(name));
            let rel_table = from.as_deref().unwrap_or(name);

            let mut nested_st = Struct::new(&nested_name);
            nested_st.vis("pub");
            nested_st.derive("Debug");
            nested_st.derive("Clone");
            nested_st.derive("Facet");
            nested_st.attr("facet(crate = dibs_runtime::facet)");

            for f in select {
                match f {
                    Field::Column { name: col_name, .. } => {
                        let rust_ty = ctx
                            .schema
                            .column_type(rel_table, col_name)
                            .unwrap_or_else(|| "String".to_string());
                        nested_st.field(format!("pub {}", col_name), &rust_ty);
                    }
                    Field::Relation {
                        name: rel_name,
                        first: rel_first,
                        ..
                    } => {
                        // Nested relation field - namespace with current struct name
                        let nested_rel_name =
                            format!("{}{}", nested_name, to_pascal_case(rel_name));
                        let ty = if *rel_first {
                            format!("Option<{}>", nested_rel_name)
                        } else {
                            format!("Vec<{}>", nested_rel_name)
                        };
                        nested_st.field(format!("pub {}", rel_name), &ty);
                    }
                    Field::Count {
                        name: count_name, ..
                    } => {
                        nested_st.field(format!("pub {}", count_name), "i64");
                    }
                }
            }

            scope.push_struct(nested_st);

            // Recursively generate structs for nested relations
            generate_nested_structs(ctx, &nested_name, select, scope);
        }
    }
}

fn generate_query_function(
    ctx: &CodegenContext,
    query: &Query,
    struct_name: &str,
    scope: &mut Scope,
) {
    let fn_name = to_snake_case(&query.name);

    let return_ty = if query.first {
        format!("Result<Option<{}>, QueryError>", struct_name)
    } else {
        format!("Result<Vec<{}>, QueryError>", struct_name)
    };

    let mut func = Function::new(&fn_name);
    if let Some(doc) = &query.doc_comment {
        func.doc(doc);
    }
    func.vis("pub");
    func.set_async(true);
    func.generic("C");
    func.arg("client", "&C");
    // Allow clone_on_copy since we generate .clone() calls on parent IDs that might be Copy types
    func.attr("allow(clippy::clone_on_copy)");

    for param in &query.params {
        let rust_ty = param_type_to_rust(&param.ty);
        func.arg(&param.name, format!("&{}", rust_ty));
    }

    func.ret(&return_ty);
    func.bound("C", "tokio_postgres::GenericClient");

    // Generate function body
    if let Some(raw_sql) = &query.raw_sql {
        let body = generate_raw_query_body(query, raw_sql);
        func.line(block_to_string(&body));
    } else {
        // Always use the planner-based SQL generation (it falls back to simple if needed)
        let body = generate_query_body(ctx, query, struct_name);
        func.line(body);
    };

    scope.push_fn(func);
}

/// Check if query has any Vec (has-many) relations.
fn has_vec_relations(query: &Query) -> bool {
    query
        .select
        .iter()
        .any(|f| matches!(f, Field::Relation { first: false, .. }))
}

/// Check if any relation has nested Vec relations.
fn has_nested_vec_relations(fields: &[Field]) -> bool {
    for field in fields {
        if let Field::Relation {
            first: false,
            select,
            ..
        } = field
        {
            // This Vec relation has nested Vec relations
            if select
                .iter()
                .any(|f| matches!(f, Field::Relation { first: false, .. }))
            {
                return true;
            }
            // Check recursively
            if has_nested_vec_relations(select) {
                return true;
            }
        }
    }
    false
}

/// Generate query body for all queries (with or without JOINs).
fn generate_query_body(ctx: &CodegenContext, query: &Query, struct_name: &str) -> String {
    let generated = match generate_sql_with_joins(query, ctx.planner_schema) {
        Ok(g) => g,
        Err(e) => {
            // Fallback: generate simple SQL and use from_row()
            let simple = generate_simple_sql(query);
            let block = generate_from_row_body(query, &simple);
            return format!(
                "// Warning: JOIN planning failed: {}\n{}",
                e,
                block_to_string(&block)
            );
        }
    };

    let mut block = Block::new("");

    // SQL constant
    block.line(format!("const SQL: &str = r#\"{}\"#;", generated.sql));
    block.line("");

    // Build params array
    let params: Vec<_> = generated
        .param_order
        .iter()
        .filter(|p| !p.starts_with("__literal_"))
        .collect();

    if params.is_empty() {
        block.line("let rows = client.query(SQL, &[]).await?;");
    } else {
        let params_str = params
            .iter()
            .map(|p| p.as_str())
            .collect::<Vec<_>>()
            .join(", ");
        block.line(format!(
            "let rows = client.query(SQL, &[{}]).await?;",
            params_str
        ));
    }

    // If there's no plan (simple query with no relations), use from_row() directly
    let Some(plan) = generated.plan.as_ref() else {
        // Simple query - use from_row() for direct deserialization
        if query.first {
            let mut match_block = Block::new("match rows.into_iter().next()");
            match_block.line("Some(row) => Ok(Some(from_row(&row)?)),");
            match_block.line("None => Ok(None),");
            block.push_block(match_block);
        } else {
            block.line("rows.iter().map(|row| Ok(from_row(row)?)).collect()");
        }
        return block_to_string(&block);
    };

    block.line("");

    // Check if we have Vec relations - if so, use HashMap-based grouping
    if has_vec_relations(query) {
        if has_nested_vec_relations(&query.select) {
            block.line(generate_nested_vec_relation_assembly(
                ctx,
                &query.name,
                query,
                struct_name,
                plan,
                &generated.column_order,
            ));
        } else {
            block.line(generate_vec_relation_assembly(
                ctx,
                &query.name,
                query,
                struct_name,
                plan,
                &generated.column_order,
            ));
        }
    } else {
        block.line(generate_option_relation_assembly(
            ctx,
            &query.name,
            query,
            struct_name,
            &generated.column_order,
        ));
    }

    block_to_string(&block)
}

/// Generate a simple query body using from_row() for direct deserialization.
/// Used when there are no relations that require manual assembly.
fn generate_from_row_body(query: &Query, generated: &GeneratedSql) -> Block {
    let mut block = Block::new("");

    // SQL constant
    block.line(format!("const SQL: &str = r#\"{}\"#;", generated.sql));
    block.line("");

    // Query execution
    let params: Vec<_> = generated
        .param_order
        .iter()
        .filter(|p| !p.starts_with("__literal_"))
        .collect();

    if params.is_empty() {
        block.line("let rows = client.query(SQL, &[]).await?;");
    } else {
        let params_str = params
            .iter()
            .map(|p| p.as_str())
            .collect::<Vec<_>>()
            .join(", ");
        block.line(format!(
            "let rows = client.query(SQL, &[{}]).await?;",
            params_str
        ));
    }

    // Result processing
    if query.first {
        let mut match_block = Block::new("match rows.into_iter().next()");
        match_block.line("Some(row) => Ok(Some(from_row(&row)?)),");
        match_block.line("None => Ok(None),");
        block.push_block(match_block);
    } else {
        block.line("rows.iter().map(|row| Ok(from_row(row)?)).collect()");
    }

    block
}

/// Generate assembly code for queries with Vec (has-many) relations.
fn generate_vec_relation_assembly(
    ctx: &CodegenContext,
    parent_prefix: &str,
    query: &Query,
    struct_name: &str,
    plan: &crate::planner::QueryPlan,
    column_order: &HashMap<String, usize>,
) -> String {
    let mut block = Block::new("");

    // Find the parent key column from the first Vec relation
    let parent_key_column = plan
        .result_mapping
        .relations
        .values()
        .find_map(|r| r.parent_key_column.as_ref())
        .cloned()
        .unwrap_or_else(|| "id".to_string());

    let parent_key_type = ctx
        .schema
        .column_type(&query.from, &parent_key_column)
        .unwrap_or_else(|| "i64".to_string());

    block.line("// Group rows by parent ID for has-many relations");
    block.line(format!(
        "let mut grouped: std::collections::HashMap<{}, {}> = std::collections::HashMap::new();",
        parent_key_type, struct_name
    ));
    block.line("");

    // For loop over rows
    let mut for_block = Block::new("for row in rows.iter()");
    for_block.line(format!(
        "let parent_id: {} = {};",
        parent_key_type,
        row_get(&parent_key_column, column_order)
    ));
    for_block.line("");

    // Entry insertion with or_insert_with
    let mut entry_block = Block::new(format!(
        "let entry = grouped.entry(parent_id.clone()).or_insert_with(|| {}",
        struct_name
    ));

    for field in &query.select {
        match field {
            Field::Column { name, .. } => {
                entry_block.line(format!("{}: {},", name, row_get(name, column_order)));
            }
            Field::Relation {
                name,
                first,
                from,
                select,
                ..
            } => {
                if *first {
                    let rel_table = from.as_deref().unwrap_or(name);
                    let nested_name = format!("{}{}", parent_prefix, to_pascal_case(name));
                    let first_col = get_first_column(select);
                    let first_alias = format!("{}_{}", name, first_col);

                    // Build the Option relation inline
                    let mut map_block = Block::new(format!(
                        "{}: row.get::<_, Option<_>>({}).map(|{}_val| {}",
                        name,
                        col_selector(&first_alias, column_order),
                        first_alias,
                        nested_name
                    ));
                    for f in select {
                        if let Field::Column { name: col_name, .. } = f {
                            let alias = format!("{}_{}", name, col_name);
                            let rust_ty = ctx
                                .schema
                                .column_type(rel_table, col_name)
                                .unwrap_or_else(|| "String".to_string());
                            let value_expr = if rust_ty.starts_with("Option<") {
                                row_get(&alias, column_order)
                            } else if alias == first_alias {
                                format!("{}_val", first_alias)
                            } else {
                                format!(
                                    "row.get::<_, Option<_>>({}).unwrap()",
                                    col_selector(&alias, column_order)
                                )
                            };
                            map_block.line(format!("{}: {},", col_name, value_expr));
                        }
                    }
                    map_block.after("),");
                    entry_block.push_block(map_block);
                } else {
                    entry_block.line(format!("{}: vec![],", name));
                }
            }
            Field::Count { name, .. } => {
                entry_block.line(format!("{}: {},", name, row_get(name, column_order)));
            }
        }
    }
    entry_block.after(");");
    for_block.push_block(entry_block);
    for_block.line("");

    // Append to Vec relations
    for field in &query.select {
        if let Field::Relation {
            name,
            first: false,
            select,
            from,
            ..
        } = field
        {
            let rel_table = from.as_deref().unwrap_or(name);
            let nested_name = format!("{}{}", parent_prefix, to_pascal_case(name));
            let first_col = get_first_column(select);
            let first_alias = format!("{}_{}", name, first_col);

            for_block.line(format!(
                "// Append {} if present (LEFT JOIN may have NULL)",
                name
            ));

            let mut if_block = Block::new(format!(
                "if let Some({}_val) = row.get::<_, Option<_>>(\"{}\")",
                first_alias, first_alias
            ));

            let mut push_block = Block::new(format!("entry.{}.push({}", name, nested_name));
            for f in select {
                if let Field::Column { name: col_name, .. } = f {
                    let alias = format!("{}_{}", name, col_name);
                    let rust_ty = ctx
                        .schema
                        .column_type(rel_table, col_name)
                        .unwrap_or_else(|| "String".to_string());
                    let value_expr = if rust_ty.starts_with("Option<") {
                        format!("row.get(\"{}\")", alias)
                    } else if alias == first_alias {
                        format!("{}_val", first_alias)
                    } else {
                        format!("row.get::<_, Option<_>>(\"{}\").unwrap()", alias)
                    };
                    push_block.line(format!("{}: {},", col_name, value_expr));
                }
            }
            push_block.after(");");
            if_block.push_block(push_block);
            for_block.push_block(if_block);
        }
    }

    block.push_block(for_block);
    block.line("");

    if query.first {
        block.line("Ok(grouped.into_values().next())");
    } else {
        block.line("Ok(grouped.into_values().collect())");
    }

    block_to_string(&block)
}

/// Generate assembly code for queries with nested Vec relations.
///
/// This handles cases like `product → variants (Vec) → prices (Vec)` where
/// we need multi-level grouping with nested HashMaps.
fn generate_nested_vec_relation_assembly(
    ctx: &CodegenContext,
    parent_prefix: &str,
    query: &Query,
    struct_name: &str,
    plan: &crate::planner::QueryPlan,
    column_order: &HashMap<String, usize>,
) -> String {
    let mut block = Block::new("");

    // Find the parent key column from the first Vec relation
    let parent_key_column = plan
        .result_mapping
        .relations
        .values()
        .find_map(|r| r.parent_key_column.as_ref())
        .cloned()
        .unwrap_or_else(|| "id".to_string());

    let parent_key_type = ctx
        .schema
        .column_type(&query.from, &parent_key_column)
        .unwrap_or_else(|| "i64".to_string());

    // We'll track:
    // 1. Parent-level grouping (product_id → ProductResult)
    // 2. For each nested Vec, track intermediate IDs for deduplication

    block.line("// Group rows by parent ID for has-many relations with nested children");
    block.line(format!(
        "let mut grouped: std::collections::HashMap<{}, {}> = std::collections::HashMap::new();",
        parent_key_type, struct_name
    ));

    // For each Vec relation with nested Vec children, we need to track seen IDs
    // to avoid duplicates when the inner relation produces multiple rows
    for field in &query.select {
        if let Field::Relation {
            name,
            first: false,
            select,
            from,
            ..
        } = field
        {
            let rel_table = from.as_deref().unwrap_or(name);
            // Get the ID column of this relation for deduplication
            if let Some(id_col) = get_id_column(select) {
                let id_type = ctx
                    .schema
                    .column_type(rel_table, &id_col)
                    .unwrap_or_else(|| "i64".to_string());
                block.line(format!(
                    "let mut seen_{}: std::collections::HashSet<({}, {})> = std::collections::HashSet::new();",
                    name, parent_key_type, id_type
                ));

                // For nested Vec relations, track their seen IDs too
                for inner_field in select {
                    if let Field::Relation {
                        name: inner_name,
                        first: false,
                        select: inner_select,
                        from: inner_from,
                        ..
                    } = inner_field
                    {
                        let inner_table = inner_from.as_deref().unwrap_or(inner_name);
                        if let Some(inner_id_col) = get_id_column(inner_select) {
                            let inner_id_type = ctx
                                .schema
                                .column_type(inner_table, &inner_id_col)
                                .unwrap_or_else(|| "i64".to_string());
                            block.line(format!(
                                "let mut seen_{}_{}: std::collections::HashSet<({}, {}, {})> = std::collections::HashSet::new();",
                                name, inner_name, parent_key_type, id_type, inner_id_type
                            ));
                        }
                    }
                }
            }
        }
    }

    block.line("");

    // For loop over rows
    let mut for_block = Block::new("for row in rows.iter()");
    for_block.line(format!(
        "let parent_id: {} = {};",
        parent_key_type,
        row_get(&parent_key_column, column_order)
    ));
    for_block.line("");

    // Initialize the parent entry
    let mut entry_block = Block::new(format!(
        "let entry = grouped.entry(parent_id.clone()).or_insert_with(|| {}",
        struct_name
    ));

    for field in &query.select {
        match field {
            Field::Column { name, .. } => {
                entry_block.line(format!("{}: {},", name, row_get(name, column_order)));
            }
            Field::Relation { name, first, .. } => {
                if *first {
                    entry_block.line(format!("{}: None, // populated below", name));
                } else {
                    entry_block.line(format!("{}: vec![],", name));
                }
            }
            Field::Count { name, .. } => {
                entry_block.line(format!("{}: row.get(\"{}\"),", name, name));
            }
        }
    }
    entry_block.after(");");
    for_block.push_block(entry_block);
    for_block.line("");

    // Handle each relation
    for field in &query.select {
        match field {
            Field::Relation {
                name,
                first: true,
                select,
                from,
                ..
            } => {
                // Option relation - populate if entry.field is None
                let rel_table = from.as_deref().unwrap_or(name);
                let nested_name = format!("{}{}", parent_prefix, to_pascal_case(name));
                let first_col = get_first_column(select);
                let first_alias = format!("{}_{}", name, first_col);

                for_block.line(format!("// Populate {} (Option) if not yet set", name));

                let mut if_none_block = Block::new(format!("if entry.{}.is_none()", name));
                let mut map_block = Block::new(format!(
                    "entry.{} = row.get::<_, Option<_>>({}).map(|{}_val| {}",
                    name,
                    col_selector(&first_alias, column_order),
                    first_alias,
                    nested_name
                ));

                for f in select {
                    if let Field::Column { name: col_name, .. } = f {
                        let alias = format!("{}_{}", name, col_name);
                        let rust_ty = ctx
                            .schema
                            .column_type(rel_table, col_name)
                            .unwrap_or_else(|| "String".to_string());
                        let value_expr = if rust_ty.starts_with("Option<") {
                            row_get(&alias, column_order)
                        } else if alias == first_alias {
                            format!("{}_val", first_alias)
                        } else {
                            format!(
                                "row.get::<_, Option<_>>({}).unwrap()",
                                col_selector(&alias, column_order)
                            )
                        };
                        map_block.line(format!("{}: {},", col_name, value_expr));
                    }
                }
                map_block.after(");");
                if_none_block.push_block(map_block);
                for_block.push_block(if_none_block);
                for_block.line("");
            }
            Field::Relation {
                name,
                first: false,
                select,
                from,
                ..
            } => {
                let rel_table = from.as_deref().unwrap_or(name);
                let nested_name = format!("{}{}", parent_prefix, to_pascal_case(name));
                let first_col = get_first_column(select);
                let first_alias = format!("{}_{}", name, first_col);

                // Check if this relation has nested Vec relations
                let has_nested_vec = select
                    .iter()
                    .any(|f| matches!(f, Field::Relation { first: false, .. }));

                if has_nested_vec {
                    generate_nested_vec_with_dedup(
                        ctx,
                        &mut for_block,
                        name,
                        rel_table,
                        &nested_name,
                        select,
                        column_order,
                    );
                } else {
                    // Simple Vec relation without nested Vec children
                    for_block.line(format!(
                        "// Append {} if present (LEFT JOIN may have NULL)",
                        name
                    ));

                    let mut if_some_block = Block::new(format!(
                        "if let Some({}_val) = row.get::<_, Option<_>>({})",
                        first_alias,
                        col_selector(&first_alias, column_order)
                    ));

                    let mut push_block = Block::new(format!("entry.{}.push({}", name, nested_name));
                    for f in select {
                        if let Field::Column { name: col_name, .. } = f {
                            let alias = format!("{}_{}", name, col_name);
                            let rust_ty = ctx
                                .schema
                                .column_type(rel_table, col_name)
                                .unwrap_or_else(|| "String".to_string());
                            let value_expr = if rust_ty.starts_with("Option<") {
                                row_get(&alias, column_order)
                            } else if alias == first_alias {
                                format!("{}_val", first_alias)
                            } else {
                                format!(
                                    "row.get::<_, Option<_>>({}).unwrap()",
                                    col_selector(&alias, column_order)
                                )
                            };
                            push_block.line(format!("{}: {},", col_name, value_expr));
                        }
                    }
                    push_block.after(");");
                    if_some_block.push_block(push_block);
                    for_block.push_block(if_some_block);
                    for_block.line("");
                }
            }
            _ => {}
        }
    }

    block.push_block(for_block);
    block.line("");

    if query.first {
        block.line("Ok(grouped.into_values().next())");
    } else {
        block.line("Ok(grouped.into_values().collect())");
    }

    block_to_string(&block)
}

/// Helper to generate nested Vec relation with deduplication logic.
fn generate_nested_vec_with_dedup(
    ctx: &CodegenContext,
    for_block: &mut Block,
    name: &str,
    rel_table: &str,
    nested_name: &str,
    select: &[Field],
    column_order: &HashMap<String, usize>,
) {
    let first_col = get_first_column(select);
    let id_col = get_id_column(select).unwrap_or_else(|| first_col.clone());
    let id_alias = format!("{}_{}", name, id_col);
    let id_type = ctx
        .schema
        .column_type(rel_table, &id_col)
        .unwrap_or_else(|| "i64".to_string());

    for_block.line(format!(
        "// Append {} if present (with deduplication for nested relations)",
        name
    ));

    let mut if_some_block = Block::new(format!(
        "if let Some({}_id) = row.get::<_, Option<{}>>({}) ",
        name,
        id_type,
        col_selector(&id_alias, column_order)
    ));

    if_some_block.line(format!(
        "let key = (parent_id.clone(), {}_id.clone());",
        name
    ));

    let mut if_insert_block = Block::new(format!("if seen_{}.insert(key)", name));
    if_insert_block.line(format!("// First time seeing this {}", name));

    // Build the nested struct
    let mut push_block = Block::new(format!("entry.{}.push({}", name, nested_name));
    for f in select {
        match f {
            Field::Column { name: col_name, .. } => {
                let alias = format!("{}_{}", name, col_name);
                let rust_ty = ctx
                    .schema
                    .column_type(rel_table, col_name)
                    .unwrap_or_else(|| "String".to_string());
                let value_expr = if rust_ty.starts_with("Option<") {
                    row_get(&alias, column_order)
                } else {
                    format!(
                        "row.get::<_, Option<_>>({}).unwrap()",
                        col_selector(&alias, column_order)
                    )
                };
                push_block.line(format!("{}: {},", col_name, value_expr));
            }
            Field::Relation {
                name: inner_name,
                first: inner_first,
                ..
            } => {
                if *inner_first {
                    push_block.line(format!("{}: None, // populated below", inner_name));
                } else {
                    push_block.line(format!("{}: vec![],", inner_name));
                }
            }
            Field::Count {
                name: count_name, ..
            } => {
                let alias = format!("{}_{}", name, count_name);
                push_block.line(format!(
                    "{}: {},",
                    count_name,
                    row_get(&alias, column_order)
                ));
            }
        }
    }
    push_block.after(");");
    if_insert_block.push_block(push_block);
    if_some_block.push_block(if_insert_block);
    if_some_block.line("");

    // Now handle nested relations - find the parent we just created or already exists
    if_some_block.line(format!(
        "// Find the {} entry to append nested children",
        name
    ));

    let mut if_find_block = Block::new(format!(
        "if let Some({}_entry) = entry.{}.iter_mut().find(|e| e.{} == {}_id)",
        name, name, id_col, name
    ));

    // Handle nested relations
    for inner_field in select {
        if let Field::Relation {
            name: inner_name,
            first: inner_first,
            select: inner_select,
            from: inner_from,
            ..
        } = inner_field
        {
            let inner_table = inner_from.as_deref().unwrap_or(inner_name);
            let inner_nested_name = format!("{}{}", nested_name, to_pascal_case(inner_name));
            let inner_first_col = get_first_column(inner_select);
            let inner_first_alias = format!("{}_{}_{}", name, inner_name, inner_first_col);

            if *inner_first {
                // Option nested relation
                let mut if_inner_none =
                    Block::new(format!("if {}_entry.{}.is_none()", name, inner_name));

                let mut inner_map_block = Block::new(format!(
                    "{}_entry.{} = row.get::<_, Option<_>>({}).map(|_val| {}",
                    name,
                    inner_name,
                    col_selector(&inner_first_alias, column_order),
                    inner_nested_name
                ));

                for inner_f in inner_select {
                    if let Field::Column {
                        name: inner_col_name,
                        ..
                    } = inner_f
                    {
                        let alias = format!("{}_{}_{}", name, inner_name, inner_col_name);
                        let rust_ty = ctx
                            .schema
                            .column_type(inner_table, inner_col_name)
                            .unwrap_or_else(|| "String".to_string());
                        let value_expr = if rust_ty.starts_with("Option<") {
                            row_get(&alias, column_order)
                        } else if alias == inner_first_alias {
                            "_val".to_string()
                        } else {
                            format!(
                                "row.get::<_, Option<_>>({}).unwrap()",
                                col_selector(&alias, column_order)
                            )
                        };
                        inner_map_block.line(format!("{}: {},", inner_col_name, value_expr));
                    }
                }
                inner_map_block.after(");");
                if_inner_none.push_block(inner_map_block);
                if_find_block.push_block(if_inner_none);
            } else {
                // Vec nested relation - need deduplication
                let inner_id_col =
                    get_id_column(inner_select).unwrap_or_else(|| inner_first_col.clone());
                let inner_id_alias = format!("{}_{}_{}", name, inner_name, inner_id_col);
                let inner_id_type = ctx
                    .schema
                    .column_type(inner_table, &inner_id_col)
                    .unwrap_or_else(|| "i64".to_string());

                let mut if_inner_some = Block::new(format!(
                    "if let Some({}_id) = row.get::<_, Option<{}>>({}) ",
                    inner_name,
                    inner_id_type,
                    col_selector(&inner_id_alias, column_order)
                ));

                if_inner_some.line(format!(
                    "let inner_key = (parent_id.clone(), {}_id.clone(), {}_id.clone());",
                    name, inner_name
                ));

                let mut if_inner_insert =
                    Block::new(format!("if seen_{}_{}.insert(inner_key)", name, inner_name));

                let mut inner_push_block = Block::new(format!(
                    "{}_entry.{}.push({}",
                    name, inner_name, inner_nested_name
                ));

                for inner_f in inner_select {
                    if let Field::Column {
                        name: inner_col_name,
                        ..
                    } = inner_f
                    {
                        let alias = format!("{}_{}_{}", name, inner_name, inner_col_name);
                        let rust_ty = ctx
                            .schema
                            .column_type(inner_table, inner_col_name)
                            .unwrap_or_else(|| "String".to_string());
                        let value_expr = if rust_ty.starts_with("Option<") {
                            row_get(&alias, column_order)
                        } else {
                            format!(
                                "row.get::<_, Option<_>>({}).unwrap()",
                                col_selector(&alias, column_order)
                            )
                        };
                        inner_push_block.line(format!("{}: {},", inner_col_name, value_expr));
                    }
                }
                inner_push_block.after(");");
                if_inner_insert.push_block(inner_push_block);
                if_inner_some.push_block(if_inner_insert);
                if_find_block.push_block(if_inner_some);
            }
        }
    }

    if_some_block.push_block(if_find_block);
    for_block.push_block(if_some_block);
    for_block.line("");
}

/// Get the "id" column from a list of fields, if present.
fn get_id_column(select: &[Field]) -> Option<String> {
    select.iter().find_map(|f| {
        if let Field::Column { name, .. } = f
            && name == "id"
        {
            return Some(name.clone());
        }
        None
    })
}

/// Generate assembly code for queries with only Option relations.
fn generate_option_relation_assembly(
    ctx: &CodegenContext,
    parent_prefix: &str,
    query: &Query,
    struct_name: &str,
    column_order: &HashMap<String, usize>,
) -> String {
    let mut block = Block::new("");

    block.line("// Assemble flat rows into nested structs");

    let mut map_block =
        Block::new("let results: Result<Vec<_>, QueryError> = rows.iter().map(|row|");

    // Extract base table columns and COUNT fields
    for field in &query.select {
        match field {
            Field::Column { name, .. } => {
                let rust_ty = ctx
                    .schema
                    .column_type(&query.from, name)
                    .unwrap_or_else(|| "String".to_string());
                map_block.line(format!(
                    "let {}: {} = {};",
                    name,
                    rust_ty,
                    row_get(name, column_order)
                ));
            }
            Field::Count { name, .. } => {
                map_block.line(format!(
                    "let {}: i64 = {};",
                    name,
                    row_get(name, column_order)
                ));
            }
            _ => {}
        }
    }

    // Extract relation columns and build nested structs
    for field in &query.select {
        if let Field::Relation {
            name,
            first,
            select,
            from,
            ..
        } = field
        {
            let rel_table = from.as_deref().unwrap_or(name);
            let nested_name = format!("{}{}", parent_prefix, to_pascal_case(name));

            for f in select {
                if let Field::Column { name: col_name, .. } = f {
                    let rust_ty = ctx
                        .schema
                        .column_type(rel_table, col_name)
                        .unwrap_or_else(|| "String".to_string());
                    let alias = format!("{}_{}", name, col_name);
                    let wrapped_ty = if rust_ty.starts_with("Option<") {
                        rust_ty.clone()
                    } else {
                        format!("Option<{}>", rust_ty)
                    };
                    map_block.line(format!(
                        "let {}: {} = {};",
                        alias,
                        wrapped_ty,
                        row_get(&alias, column_order)
                    ));
                }
            }

            if *first {
                let first_col = get_first_column(select);
                let first_alias = format!("{}_{}", name, first_col);

                let first_col_type = ctx
                    .schema
                    .column_type(rel_table, &first_col)
                    .unwrap_or_else(|| "String".to_string());
                let first_col_is_optional = first_col_type.starts_with("Option<");

                let mut rel_block = Block::new(format!(
                    "let {} = {}.map(|{}_val| {}",
                    name, first_alias, first_alias, nested_name
                ));

                for f in select {
                    if let Field::Column { name: col_name, .. } = f {
                        let alias = format!("{}_{}", name, col_name);
                        let rust_ty = ctx
                            .schema
                            .column_type(rel_table, col_name)
                            .unwrap_or_else(|| "String".to_string());
                        let value_expr = if alias == first_alias {
                            if first_col_is_optional {
                                format!("Some({}_val)", first_alias)
                            } else {
                                format!("{}_val", first_alias)
                            }
                        } else if rust_ty.starts_with("Option<") {
                            alias.clone()
                        } else {
                            format!("{}.unwrap()", alias)
                        };
                        rel_block.line(format!("{}: {},", col_name, value_expr));
                    }
                }
                rel_block.after(");");
                map_block.push_block(rel_block);
            }
        }
    }

    // Build the result struct
    let mut result_block = Block::new(format!("Ok({}", struct_name));
    for field in &query.select {
        match field {
            Field::Column { name, .. }
            | Field::Relation { name, .. }
            | Field::Count { name, .. } => {
                result_block.line(format!("{},", name));
            }
        }
    }
    result_block.after(")");
    map_block.push_block(result_block);

    map_block.after(").collect();");
    block.push_block(map_block);
    block.line("");

    if query.first {
        block.line("Ok(results?.into_iter().next())");
    } else {
        block.line("results");
    }

    block_to_string(&block)
}

fn generate_raw_query_body(query: &Query, raw_sql: &str) -> Block {
    let cleaned: String = raw_sql
        .lines()
        .map(|l| l.trim())
        .collect::<Vec<_>>()
        .join("\n");

    let mut block = Block::new("");

    // SQL constant
    block.line(format!("const SQL: &str = r#\"{}\"#;", cleaned.trim()));
    block.line("");

    // Query execution
    if query.params.is_empty() {
        block.line("let rows = client.query(SQL, &[]).await?;");
    } else {
        let params_str = query
            .params
            .iter()
            .map(|p| p.name.as_str())
            .collect::<Vec<_>>()
            .join(", ");
        block.line(format!(
            "let rows = client.query(SQL, &[{}]).await?;",
            params_str
        ));
    }

    // Result processing
    if query.first {
        let mut match_block = Block::new("match rows.into_iter().next()");
        match_block.line("Some(row) => Ok(Some(from_row(&row)?)),");
        match_block.line("None => Ok(None),");
        block.push_block(match_block);
    } else {
        block.line("rows.iter().map(|row| Ok(from_row(row)?)).collect()");
    }

    block
}

fn get_first_column(select: &[Field]) -> String {
    select
        .iter()
        .find_map(|f| {
            if let Field::Column { name, .. } = f {
                Some(name.clone())
            } else {
                None
            }
        })
        .unwrap_or_default()
}

fn param_type_to_rust(ty: &ParamType) -> String {
    match ty {
        ParamType::String => "String".to_string(),
        ParamType::Int => "i64".to_string(),
        ParamType::Bool => "bool".to_string(),
        ParamType::Uuid => "Uuid".to_string(),
        ParamType::Decimal => "Decimal".to_string(),
        ParamType::Timestamp => "Timestamp".to_string(),
        ParamType::Bytes => "Vec<u8>".to_string(),
        ParamType::Optional(inner) => format!("Option<{}>", param_type_to_rust(inner)),
    }
}

/// Helper to format a Block to a String.
fn block_to_string(block: &Block) -> String {
    let mut output = String::new();
    let mut formatter = codegen::Formatter::new(&mut output);
    block.fmt(&mut formatter).expect("formatting failed");
    output
}

fn to_pascal_case(s: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = true;

    for c in s.chars() {
        if c == '_' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }

    result
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();

    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }

    result
}

// ============================================================================
// Mutation code generation
// ============================================================================

fn generate_insert_code(_ctx: &CodegenContext, insert: &InsertMutation, scope: &mut Scope) {
    let fn_name = to_snake_case(&insert.name);
    let generated = crate::sql::generate_insert_sql(insert);

    // Generate result struct if RETURNING is used
    let return_ty = if insert.returning.is_empty() {
        "Result<u64, QueryError>".to_string()
    } else {
        let struct_name = format!("{}Result", insert.name);
        generate_mutation_result_struct(
            _ctx,
            &struct_name,
            &insert.table,
            &insert.returning,
            scope,
        );
        format!("Result<Option<{}>, QueryError>", struct_name)
    };

    let mut func = Function::new(&fn_name);
    if let Some(doc) = &insert.doc_comment {
        func.doc(doc);
    }
    func.vis("pub");
    func.set_async(true);
    func.generic("C");
    func.arg("client", "&C");

    for param in &insert.params {
        let rust_ty = param_type_to_rust(&param.ty);
        func.arg(&param.name, format!("&{}", rust_ty));
    }

    func.ret(&return_ty);
    func.bound("C", "tokio_postgres::GenericClient");

    let body = generate_mutation_body(&generated, insert.returning.is_empty());
    func.line(block_to_string(&body));

    scope.push_fn(func);
}

fn generate_upsert_code(_ctx: &CodegenContext, upsert: &UpsertMutation, scope: &mut Scope) {
    let fn_name = to_snake_case(&upsert.name);
    let generated = crate::sql::generate_upsert_sql(upsert);

    let return_ty = if upsert.returning.is_empty() {
        "Result<u64, QueryError>".to_string()
    } else {
        let struct_name = format!("{}Result", upsert.name);
        generate_mutation_result_struct(
            _ctx,
            &struct_name,
            &upsert.table,
            &upsert.returning,
            scope,
        );
        format!("Result<Option<{}>, QueryError>", struct_name)
    };

    let mut func = Function::new(&fn_name);
    if let Some(doc) = &upsert.doc_comment {
        func.doc(doc);
    }
    func.vis("pub");
    func.set_async(true);
    func.generic("C");
    func.arg("client", "&C");

    for param in &upsert.params {
        let rust_ty = param_type_to_rust(&param.ty);
        func.arg(&param.name, format!("&{}", rust_ty));
    }

    func.ret(&return_ty);
    func.bound("C", "tokio_postgres::GenericClient");

    let body = generate_mutation_body(&generated, upsert.returning.is_empty());
    func.line(block_to_string(&body));

    scope.push_fn(func);
}

fn generate_update_code(_ctx: &CodegenContext, update: &UpdateMutation, scope: &mut Scope) {
    let fn_name = to_snake_case(&update.name);
    let generated = crate::sql::generate_update_sql(update);

    let return_ty = if update.returning.is_empty() {
        "Result<u64, QueryError>".to_string()
    } else {
        let struct_name = format!("{}Result", update.name);
        generate_mutation_result_struct(
            _ctx,
            &struct_name,
            &update.table,
            &update.returning,
            scope,
        );
        format!("Result<Option<{}>, QueryError>", struct_name)
    };

    let mut func = Function::new(&fn_name);
    if let Some(doc) = &update.doc_comment {
        func.doc(doc);
    }
    func.vis("pub");
    func.set_async(true);
    func.generic("C");
    func.arg("client", "&C");

    for param in &update.params {
        let rust_ty = param_type_to_rust(&param.ty);
        func.arg(&param.name, format!("&{}", rust_ty));
    }

    func.ret(&return_ty);
    func.bound("C", "tokio_postgres::GenericClient");

    let body = generate_mutation_body(&generated, update.returning.is_empty());
    func.line(block_to_string(&body));

    scope.push_fn(func);
}

fn generate_delete_code(_ctx: &CodegenContext, delete: &DeleteMutation, scope: &mut Scope) {
    let fn_name = to_snake_case(&delete.name);
    let generated = crate::sql::generate_delete_sql(delete);

    let return_ty = if delete.returning.is_empty() {
        "Result<u64, QueryError>".to_string()
    } else {
        let struct_name = format!("{}Result", delete.name);
        generate_mutation_result_struct(
            _ctx,
            &struct_name,
            &delete.table,
            &delete.returning,
            scope,
        );
        format!("Result<Option<{}>, QueryError>", struct_name)
    };

    let mut func = Function::new(&fn_name);
    if let Some(doc) = &delete.doc_comment {
        func.doc(doc);
    }
    func.vis("pub");
    func.set_async(true);
    func.generic("C");
    func.arg("client", "&C");

    for param in &delete.params {
        let rust_ty = param_type_to_rust(&param.ty);
        func.arg(&param.name, format!("&{}", rust_ty));
    }

    func.ret(&return_ty);
    func.bound("C", "tokio_postgres::GenericClient");

    let body = generate_mutation_body(&generated, delete.returning.is_empty());
    func.line(block_to_string(&body));

    scope.push_fn(func);
}

fn generate_mutation_result_struct(
    ctx: &CodegenContext,
    struct_name: &str,
    table: &str,
    returning: &[String],
    scope: &mut Scope,
) {
    let mut st = Struct::new(struct_name);
    st.vis("pub");
    st.derive("Debug");
    st.derive("Clone");
    st.derive("Facet");
    st.attr("facet(crate = dibs_runtime::facet)");

    for col in returning {
        let rust_ty = ctx
            .schema
            .column_type(table, col)
            .unwrap_or_else(|| "String".to_string());
        st.field(format!("pub {}", col), &rust_ty);
    }

    scope.push_struct(st);
}

fn generate_mutation_body(generated: &crate::sql::GeneratedSql, execute_only: bool) -> Block {
    let mut block = Block::new("");

    // SQL constant
    block.line(format!("const SQL: &str = r#\"{}\"#;", generated.sql));
    block.line("");

    let params: Vec<_> = generated
        .param_order
        .iter()
        .filter(|p| !p.starts_with("__literal_"))
        .collect();

    if execute_only {
        // No RETURNING - use execute
        if params.is_empty() {
            block.line("let affected = client.execute(SQL, &[]).await?;");
        } else {
            let params_str = params
                .iter()
                .map(|p| p.as_str())
                .collect::<Vec<_>>()
                .join(", ");
            block.line(format!(
                "let affected = client.execute(SQL, &[{}]).await?;",
                params_str
            ));
        }
        block.line("Ok(affected)");
    } else {
        // Has RETURNING - use query
        if params.is_empty() {
            block.line("let rows = client.query(SQL, &[]).await?;");
        } else {
            let params_str = params
                .iter()
                .map(|p| p.as_str())
                .collect::<Vec<_>>()
                .join(", ");
            block.line(format!(
                "let rows = client.query(SQL, &[{}]).await?;",
                params_str
            ));
        }
        let mut match_block = Block::new("match rows.into_iter().next()");
        match_block.line("Some(row) => Ok(Some(from_row(&row)?)),");
        match_block.line("None => Ok(None),");
        block.push_block(match_block);
    }

    block
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parse::parse_query_file;

    #[test]
    fn test_generate_simple_query() {
        let source = r#"
AllProducts @query{
  from product
  select{ id, handle, status }
}
"#;
        let file = parse_query_file(source).unwrap();
        let code = generate_rust_code(&file);

        assert!(code.code.contains("pub struct AllProductsResult"));
        assert!(code.code.contains("pub async fn all_products"));
        assert!(code.code.contains("pub id: String"));
        assert!(code.code.contains("pub handle: String"));
        assert!(code.code.contains("#[derive(Debug, Clone, Facet)]"));
    }

    #[test]
    fn test_generate_query_with_params() {
        let source = r#"
ProductByHandle @query{
  params{ handle @string }
  from product
  where{ handle $handle }
  first true
  select{ id, handle }
}
"#;
        let file = parse_query_file(source).unwrap();
        let code = generate_rust_code(&file);

        assert!(code.code.contains("handle: &String"));
        assert!(code.code.contains("from_row"));
        assert!(code.code.contains("Ok(None)"));
    }

    #[test]
    fn test_generate_query_with_relation() {
        let source = r#"
ProductListing @query{
  from product
  select{
    id
    translation @rel{
      first true
      select{ title, description }
    }
  }
}
"#;
        let file = parse_query_file(source).unwrap();
        let code = generate_rust_code(&file);

        assert!(
            code.code
                .contains("pub translation: Option<ProductListingTranslation>")
        );
        assert!(code.code.contains("pub struct ProductListingTranslation"));
        assert!(code.code.contains("pub title: String"));
    }

    #[test]
    fn test_generate_raw_sql_query() {
        let source = r#"
TrendingProducts @query{
  params{
    locale @string
    days @int
  }
  sql <<SQL
    SELECT id, title FROM products WHERE locale = $1
  SQL
  returns{
    id @int
    title @string
  }
}
"#;
        let file = parse_query_file(source).unwrap();
        let code = generate_rust_code(&file);

        assert!(code.code.contains("locale: &String"));
        assert!(code.code.contains("days: &i64"));
        assert!(code.code.contains("pub id: i64"));
        assert!(code.code.contains("pub title: String"));
        assert!(code.code.contains("SELECT id, title FROM products"));
    }

    #[test]
    fn test_snake_case() {
        assert_eq!(to_snake_case("ProductListing"), "product_listing");
        assert_eq!(to_snake_case("AllProducts"), "all_products");
        assert_eq!(to_snake_case("ID"), "i_d");
    }

    #[test]
    fn test_pascal_case() {
        assert_eq!(to_pascal_case("translation"), "Translation");
        assert_eq!(to_pascal_case("product_variant"), "ProductVariant");
    }

    #[test]
    fn test_generate_join_query() {
        use crate::planner::{PlannerForeignKey, PlannerSchema, PlannerTable};

        let source = r#"
ProductWithTranslation @query{
  params{ handle @string }
  from product
  where{ handle $handle }
  first true
  select{
    id
    handle
    translation @rel{
      from product_translation
      first true
      select{ title, description }
    }
  }
}
"#;
        let file = parse_query_file(source).unwrap();

        let mut schema = SchemaInfo::default();
        let mut product_cols = HashMap::new();
        product_cols.insert(
            "id".to_string(),
            ColumnInfo {
                rust_type: "i64".to_string(),
                nullable: false,
            },
        );
        product_cols.insert(
            "handle".to_string(),
            ColumnInfo {
                rust_type: "String".to_string(),
                nullable: false,
            },
        );
        schema.tables.insert(
            "product".to_string(),
            TableInfo {
                columns: product_cols,
            },
        );

        let mut translation_cols = HashMap::new();
        translation_cols.insert(
            "title".to_string(),
            ColumnInfo {
                rust_type: "String".to_string(),
                nullable: false,
            },
        );
        translation_cols.insert(
            "description".to_string(),
            ColumnInfo {
                rust_type: "String".to_string(),
                nullable: true,
            },
        );
        schema.tables.insert(
            "product_translation".to_string(),
            TableInfo {
                columns: translation_cols,
            },
        );

        let mut planner_schema = PlannerSchema::default();
        planner_schema.tables.insert(
            "product".to_string(),
            PlannerTable {
                name: "product".to_string(),
                columns: vec!["id".to_string(), "handle".to_string()],
                foreign_keys: vec![],
            },
        );
        planner_schema.tables.insert(
            "product_translation".to_string(),
            PlannerTable {
                name: "product_translation".to_string(),
                columns: vec![
                    "id".to_string(),
                    "product_id".to_string(),
                    "title".to_string(),
                    "description".to_string(),
                ],
                foreign_keys: vec![PlannerForeignKey {
                    columns: vec!["product_id".to_string()],
                    references_table: "product".to_string(),
                    references_columns: vec!["id".to_string()],
                }],
            },
        );

        let code = generate_rust_code_with_planner(&file, &schema, Some(&planner_schema));

        assert!(
            code.code
                .contains("pub struct ProductWithTranslationResult")
        );
        assert!(code.code.contains("pub id: i64"));
        assert!(code.code.contains("pub handle: String"));
        assert!(
            code.code
                .contains("pub translation: Option<ProductWithTranslationTranslation>")
        );
        assert!(
            code.code
                .contains("pub struct ProductWithTranslationTranslation")
        );
        assert!(code.code.contains("LEFT JOIN"));
        assert!(code.code.contains("product_translation"));
        assert!(code.code.contains("translation_title"));
        assert!(code.code.contains("translation_description"));
        // Check that translation struct construction happens inside a .map() call
        // The exact variable name depends on HashMap iteration order
        assert!(
            code.code
                .contains(".map(|translation_description_val| ProductWithTranslationTranslation")
                || code
                    .code
                    .contains(".map(|translation_title_val| ProductWithTranslationTranslation"),
            "Expected relation construction inside .map() call"
        );
        // Check that title field is populated
        assert!(
            code.code.contains("title: translation_title")
                || code.code.contains("title: translation_title_val"),
            "Expected title field assignment"
        );
    }

    #[facet_testhelpers::test]
    fn test_generate_vec_relation_query() {
        use crate::planner::{PlannerForeignKey, PlannerSchema, PlannerTable};

        let source = r#"
ProductWithVariants @query{
  from product
  select{
    id
    handle
    variants @rel{
      from product_variant
      select{ id, sku }
    }
  }
}
"#;
        let file = parse_query_file(source).unwrap();

        let mut schema = SchemaInfo::default();
        let mut product_cols = HashMap::new();
        product_cols.insert(
            "id".to_string(),
            ColumnInfo {
                rust_type: "i64".to_string(),
                nullable: false,
            },
        );
        product_cols.insert(
            "handle".to_string(),
            ColumnInfo {
                rust_type: "String".to_string(),
                nullable: false,
            },
        );
        schema.tables.insert(
            "product".to_string(),
            TableInfo {
                columns: product_cols,
            },
        );

        let mut variant_cols = HashMap::new();
        variant_cols.insert(
            "id".to_string(),
            ColumnInfo {
                rust_type: "i64".to_string(),
                nullable: false,
            },
        );
        variant_cols.insert(
            "sku".to_string(),
            ColumnInfo {
                rust_type: "String".to_string(),
                nullable: false,
            },
        );
        schema.tables.insert(
            "product_variant".to_string(),
            TableInfo {
                columns: variant_cols,
            },
        );

        let mut planner_schema = PlannerSchema::default();
        planner_schema.tables.insert(
            "product".to_string(),
            PlannerTable {
                name: "product".to_string(),
                columns: vec!["id".to_string(), "handle".to_string()],
                foreign_keys: vec![],
            },
        );
        planner_schema.tables.insert(
            "product_variant".to_string(),
            PlannerTable {
                name: "product_variant".to_string(),
                columns: vec![
                    "id".to_string(),
                    "product_id".to_string(),
                    "sku".to_string(),
                ],
                foreign_keys: vec![PlannerForeignKey {
                    columns: vec!["product_id".to_string()],
                    references_table: "product".to_string(),
                    references_columns: vec!["id".to_string()],
                }],
            },
        );

        let code = generate_rust_code_with_planner(&file, &schema, Some(&planner_schema));

        tracing::info!("Generated code:\n{}", code.code);

        assert!(
            code.code.contains("pub struct ProductWithVariantsResult"),
            "Should generate result struct"
        );
        assert!(code.code.contains("pub id: i64"), "Should have id field");
        assert!(
            code.code.contains("pub handle: String"),
            "Should have handle field"
        );
        assert!(
            code.code
                .contains("pub variants: Vec<ProductWithVariantsVariants>"),
            "Should have Vec variants field"
        );
        assert!(
            code.code.contains("pub struct ProductWithVariantsVariants"),
            "Should generate nested Variants struct"
        );
        assert!(code.code.contains("LEFT JOIN"), "Should use LEFT JOIN");
        assert!(
            code.code.contains("product_variant"),
            "Should join product_variant"
        );
        assert!(
            code.code.contains("HashMap"),
            "Should use HashMap for grouping"
        );
        assert!(
            code.code.contains("grouped.entry"),
            "Should use entry API for grouping"
        );
        assert!(code.code.contains(".push("), "Should push to Vec relation");
        assert!(
            code.code.contains("variants: vec![]"),
            "Should initialize Vec as empty"
        );
        assert!(
            code.code.contains("entry.variants.push"),
            "Should append to variants"
        );
    }

    #[facet_testhelpers::test]
    fn test_generate_count_query() {
        use crate::planner::{PlannerForeignKey, PlannerSchema, PlannerTable};

        let source = r#"
ProductWithVariantCount @query{
  from product
  select{
    id
    handle
    variant_count @count(product_variant)
  }
}
"#;
        let file = parse_query_file(source).unwrap();

        let mut schema = SchemaInfo::default();
        let mut product_cols = HashMap::new();
        product_cols.insert(
            "id".to_string(),
            ColumnInfo {
                rust_type: "i64".to_string(),
                nullable: false,
            },
        );
        product_cols.insert(
            "handle".to_string(),
            ColumnInfo {
                rust_type: "String".to_string(),
                nullable: false,
            },
        );
        schema.tables.insert(
            "product".to_string(),
            TableInfo {
                columns: product_cols,
            },
        );

        let mut planner_schema = PlannerSchema::default();
        planner_schema.tables.insert(
            "product".to_string(),
            PlannerTable {
                name: "product".to_string(),
                columns: vec!["id".to_string(), "handle".to_string()],
                foreign_keys: vec![],
            },
        );
        planner_schema.tables.insert(
            "product_variant".to_string(),
            PlannerTable {
                name: "product_variant".to_string(),
                columns: vec![
                    "id".to_string(),
                    "product_id".to_string(),
                    "sku".to_string(),
                ],
                foreign_keys: vec![PlannerForeignKey {
                    columns: vec!["product_id".to_string()],
                    references_table: "product".to_string(),
                    references_columns: vec!["id".to_string()],
                }],
            },
        );

        let code = generate_rust_code_with_planner(&file, &schema, Some(&planner_schema));

        tracing::info!("Generated code:\n{}", code.code);

        assert!(
            code.code
                .contains("pub struct ProductWithVariantCountResult"),
            "Should generate result struct"
        );
        assert!(
            code.code.contains("pub variant_count: i64"),
            "Should have variant_count field as i64"
        );
        assert!(
            code.code.contains("SELECT COUNT(*)"),
            "Should generate COUNT subquery in SQL"
        );
        assert!(
            code.code.contains("product_variant"),
            "Should reference product_variant table in COUNT"
        );
        assert!(
            code.code.contains("variant_count"),
            "Should alias the COUNT result"
        );
    }

    #[facet_testhelpers::test]
    fn test_generate_nested_vec_relation_query() {
        use crate::planner::{PlannerForeignKey, PlannerSchema, PlannerTable};

        let source = r#"
ProductWithVariantsAndPrices @query{
  from product
  select{
    id
    handle
    variants @rel{
      from product_variant
      select{
        id
        sku
        prices @rel{
          from variant_price
          select{ id, currency_code, amount }
        }
      }
    }
  }
}
"#;
        let file = parse_query_file(source).unwrap();

        let mut schema = SchemaInfo::default();
        let mut product_cols = HashMap::new();
        product_cols.insert(
            "id".to_string(),
            ColumnInfo {
                rust_type: "i64".to_string(),
                nullable: false,
            },
        );
        product_cols.insert(
            "handle".to_string(),
            ColumnInfo {
                rust_type: "String".to_string(),
                nullable: false,
            },
        );
        schema.tables.insert(
            "product".to_string(),
            TableInfo {
                columns: product_cols,
            },
        );

        let mut variant_cols = HashMap::new();
        variant_cols.insert(
            "id".to_string(),
            ColumnInfo {
                rust_type: "i64".to_string(),
                nullable: false,
            },
        );
        variant_cols.insert(
            "sku".to_string(),
            ColumnInfo {
                rust_type: "String".to_string(),
                nullable: false,
            },
        );
        schema.tables.insert(
            "product_variant".to_string(),
            TableInfo {
                columns: variant_cols,
            },
        );

        let mut price_cols = HashMap::new();
        price_cols.insert(
            "id".to_string(),
            ColumnInfo {
                rust_type: "i64".to_string(),
                nullable: false,
            },
        );
        price_cols.insert(
            "currency_code".to_string(),
            ColumnInfo {
                rust_type: "String".to_string(),
                nullable: false,
            },
        );
        price_cols.insert(
            "amount".to_string(),
            ColumnInfo {
                rust_type: "i64".to_string(),
                nullable: false,
            },
        );
        schema.tables.insert(
            "variant_price".to_string(),
            TableInfo {
                columns: price_cols,
            },
        );

        let mut planner_schema = PlannerSchema::default();
        planner_schema.tables.insert(
            "product".to_string(),
            PlannerTable {
                name: "product".to_string(),
                columns: vec!["id".to_string(), "handle".to_string()],
                foreign_keys: vec![],
            },
        );
        planner_schema.tables.insert(
            "product_variant".to_string(),
            PlannerTable {
                name: "product_variant".to_string(),
                columns: vec![
                    "id".to_string(),
                    "product_id".to_string(),
                    "sku".to_string(),
                ],
                foreign_keys: vec![PlannerForeignKey {
                    columns: vec!["product_id".to_string()],
                    references_table: "product".to_string(),
                    references_columns: vec!["id".to_string()],
                }],
            },
        );
        planner_schema.tables.insert(
            "variant_price".to_string(),
            PlannerTable {
                name: "variant_price".to_string(),
                columns: vec![
                    "id".to_string(),
                    "variant_id".to_string(),
                    "currency_code".to_string(),
                    "amount".to_string(),
                ],
                foreign_keys: vec![PlannerForeignKey {
                    columns: vec!["variant_id".to_string()],
                    references_table: "product_variant".to_string(),
                    references_columns: vec!["id".to_string()],
                }],
            },
        );

        let code = generate_rust_code_with_planner(&file, &schema, Some(&planner_schema));

        tracing::info!("Generated code:\n{}", code.code);

        // Check result structs
        assert!(
            code.code
                .contains("pub struct ProductWithVariantsAndPricesResult"),
            "Should generate top-level result struct"
        );
        assert!(
            code.code
                .contains("pub struct ProductWithVariantsAndPricesVariants"),
            "Should generate nested Variants struct"
        );
        assert!(
            code.code
                .contains("pub struct ProductWithVariantsAndPricesVariantsPrices"),
            "Should generate nested Prices struct"
        );

        // Check field types
        assert!(
            code.code
                .contains("pub variants: Vec<ProductWithVariantsAndPricesVariants>"),
            "Should have Vec variants field"
        );
        assert!(
            code.code
                .contains("pub prices: Vec<ProductWithVariantsAndPricesVariantsPrices>"),
            "Should have Vec prices field in Variants"
        );

        // Check SQL JOINs
        assert!(code.code.contains("LEFT JOIN"), "Should use LEFT JOIN");
        assert!(
            code.code.contains("product_variant"),
            "Should join product_variant"
        );
        assert!(
            code.code.contains("variant_price"),
            "Should join variant_price"
        );

        // Check nested column aliases
        assert!(
            code.code.contains("variants_prices_currency_code"),
            "Should have nested column alias"
        );

        // Check deduplication logic for nested Vec relations
        assert!(
            code.code.contains("HashSet"),
            "Should use HashSet for deduplication"
        );
        assert!(
            code.code.contains("seen_variants"),
            "Should track seen variants"
        );
        assert!(
            code.code.contains("seen_variants_prices"),
            "Should track seen nested prices"
        );
    }

    #[test]
    fn test_generate_insert_code() {
        let source = r#"
CreateUser @insert{
  params{
    name @string
    email @string
  }
  into users
  values{
    name $name
    email $email
    created_at @now
  }
  returning{ id, name, email, created_at }
}
"#;
        let file = parse_query_file(source).unwrap();
        let code = generate_rust_code(&file);

        assert!(code.code.contains("pub struct CreateUserResult"));
        assert!(code.code.contains("pub async fn create_user"));
        assert!(code.code.contains("name: &String"));
        assert!(code.code.contains("email: &String"));
        assert!(code.code.contains("INSERT INTO"));
        assert!(code.code.contains("RETURNING"));
        assert!(
            code.code
                .contains("Result<Option<CreateUserResult>, QueryError>")
        );
    }

    #[test]
    fn test_generate_upsert_code() {
        let source = r#"
UpsertProduct @upsert{
  params{
    id @uuid
    name @string
    price @decimal
  }
  into products
  on-conflict{
    target{ id }
    update{ name, price, updated_at @now }
  }
  values{
    id $id
    name $name
    price $price
  }
  returning{ id, name, price, updated_at }
}
"#;
        let file = parse_query_file(source).unwrap();
        let code = generate_rust_code(&file);

        assert!(code.code.contains("pub struct UpsertProductResult"));
        assert!(code.code.contains("pub async fn upsert_product"));
        assert!(code.code.contains("id: &Uuid"));
        assert!(code.code.contains("ON CONFLICT"));
        assert!(code.code.contains("DO UPDATE SET"));
    }

    #[test]
    fn test_generate_update_code() {
        let source = r#"
UpdateUserEmail @update{
  params{
    id @uuid
    email @string
  }
  table users
  set{
    email $email
    updated_at @now
  }
  where{ id $id }
  returning{ id, email, updated_at }
}
"#;
        let file = parse_query_file(source).unwrap();
        let code = generate_rust_code(&file);

        assert!(code.code.contains("pub struct UpdateUserEmailResult"));
        assert!(code.code.contains("pub async fn update_user_email"));
        assert!(code.code.contains("UPDATE"));
        assert!(code.code.contains("SET"));
        assert!(code.code.contains("WHERE"));
    }

    #[test]
    fn test_generate_delete_code() {
        let source = r#"
DeleteUser @delete{
  params{
    id @uuid
  }
  from users
  where{ id $id }
  returning{ id }
}
"#;
        let file = parse_query_file(source).unwrap();
        let code = generate_rust_code(&file);

        assert!(code.code.contains("pub struct DeleteUserResult"));
        assert!(code.code.contains("pub async fn delete_user"));
        assert!(code.code.contains("DELETE FROM"));
        assert!(code.code.contains("WHERE"));
    }

    #[test]
    fn test_generate_insert_without_returning() {
        let source = r#"
InsertLog @insert{
  params{
    message @string
  }
  into logs
  values{
    message $message
    created_at @now
  }
}
"#;
        let file = parse_query_file(source).unwrap();
        let code = generate_rust_code(&file);

        // Should NOT generate a result struct
        assert!(!code.code.contains("pub struct InsertLogResult"));
        assert!(code.code.contains("pub async fn insert_log"));
        // Should use execute() instead of query()
        assert!(code.code.contains("client.execute"));
        assert!(code.code.contains("Result<u64, QueryError>"));
    }
}
