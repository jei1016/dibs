//! Rust code generation from query AST.
//!
//! TODO: Replace manual string building with the `codegen` crate for cleaner code generation.

use crate::ast::*;
use crate::sql::generate_simple_sql;
use std::collections::HashMap;

/// Generated Rust code for a query file.
#[derive(Debug, Clone)]
pub struct GeneratedCode {
    /// Full Rust source code.
    pub code: String,
}

/// Schema information for code generation.
///
/// This provides type information for columns, allowing the codegen
/// to emit correctly-typed result structs.
#[derive(Debug, Clone, Default)]
pub struct SchemaInfo {
    /// Map of table name -> column info.
    pub tables: HashMap<String, TableInfo>,
}

/// Information about a single table.
#[derive(Debug, Clone, Default)]
pub struct TableInfo {
    /// Map of column name -> Rust type string.
    pub columns: HashMap<String, ColumnInfo>,
}

/// Information about a single column.
#[derive(Debug, Clone)]
pub struct ColumnInfo {
    /// Rust type name (e.g., "i64", "String", "bool").
    pub rust_type: String,
    /// Whether the column is nullable (Option<T>).
    pub nullable: bool,
}

impl SchemaInfo {
    /// Create a new empty schema.
    pub fn new() -> Self {
        Self::default()
    }

    /// Look up the Rust type for a column.
    pub fn column_type(&self, table: &str, column: &str) -> Option<String> {
        let table_info = self.tables.get(table)?;
        let col_info = table_info.columns.get(column)?;
        if col_info.nullable {
            Some(format!("Option<{}>", col_info.rust_type))
        } else {
            Some(col_info.rust_type.clone())
        }
    }
}

/// Context for code generation.
struct CodegenContext<'a> {
    schema: &'a SchemaInfo,
}

/// Generate Rust code for a query file.
pub fn generate_rust_code(file: &QueryFile) -> GeneratedCode {
    generate_rust_code_with_schema(file, &SchemaInfo::default())
}

/// Generate Rust code for a query file with schema information.
pub fn generate_rust_code_with_schema(file: &QueryFile, schema: &SchemaInfo) -> GeneratedCode {
    let ctx = CodegenContext { schema };
    let mut code = String::new();

    // Imports
    code.push_str("// Generated by dibs-query-gen. Do not edit.\n\n");
    code.push_str("use dibs_runtime::prelude::*;\n");
    code.push_str("use dibs_runtime::tokio_postgres;\n\n");

    for query in &file.queries {
        generate_query_code(&ctx, query, &mut code);
    }

    GeneratedCode { code }
}

fn generate_query_code(ctx: &CodegenContext, query: &Query, code: &mut String) {
    // Generate result struct
    let struct_name = format!("{}Result", query.name);
    generate_result_struct(ctx, query, &struct_name, &query.from, &query.select, code);

    code.push('\n');

    // Generate query function
    generate_query_function(query, &struct_name, code);

    code.push('\n');
}

fn generate_result_struct(
    ctx: &CodegenContext,
    query: &Query,
    struct_name: &str,
    table: &str,
    fields: &[Field],
    code: &mut String,
) {
    code.push_str("#[derive(Debug, Clone, Facet)]\n");
    code.push_str("#[facet(crate = dibs_runtime::facet)]\n");
    code.push_str(&format!("pub struct {} {{\n", struct_name));

    if query.is_raw() {
        // Raw SQL - use returns declaration
        for ret in &query.returns {
            let rust_ty = param_type_to_rust(&ret.ty);
            code.push_str(&format!("    pub {}: {},\n", ret.name, rust_ty));
        }
    } else {
        // Regular query - use select fields
        for field in fields {
            match field {
                Field::Column { name, .. } => {
                    // Look up type from schema, fall back to String
                    let rust_ty = ctx
                        .schema
                        .column_type(table, name)
                        .unwrap_or_else(|| "String".to_string());
                    code.push_str(&format!("    pub {}: {},\n", name, rust_ty));
                }
                Field::Relation {
                    name,
                    first,
                    select,
                    from,
                    ..
                } => {
                    // Nested struct for relation
                    let nested_name = to_pascal_case(name);
                    let ty = if *first {
                        format!("Option<{}>", nested_name)
                    } else {
                        format!("Vec<{}>", nested_name)
                    };
                    code.push_str(&format!("    pub {}: {},\n", name, ty));
                    // We'll generate nested struct after the parent
                    let _ = (select, from);
                }
                Field::Count { name, .. } => {
                    code.push_str(&format!("    pub {}: i64,\n", name));
                }
            }
        }
    }

    code.push_str("}\n");

    // Generate nested structs for relations
    if !query.is_raw() {
        for field in fields {
            if let Field::Relation {
                name,
                select,
                from,
                ..
            } = field
            {
                let nested_name = to_pascal_case(name);
                // Use explicit from table, or infer from relation name
                let rel_table = from.as_deref().unwrap_or(name);
                code.push('\n');
                code.push_str("#[derive(Debug, Clone, Facet)]\n");
    code.push_str("#[facet(crate = dibs_runtime::facet)]\n");
                code.push_str(&format!("pub struct {} {{\n", nested_name));
                for f in select {
                    if let Field::Column { name, .. } = f {
                        let rust_ty = ctx
                            .schema
                            .column_type(rel_table, name)
                            .unwrap_or_else(|| "String".to_string());
                        code.push_str(&format!("    pub {}: {},\n", name, rust_ty));
                    }
                }
                code.push_str("}\n");
            }
        }
    }
}

fn generate_query_function(query: &Query, struct_name: &str, code: &mut String) {
    let fn_name = to_snake_case(&query.name);

    // Function signature
    code.push_str(&format!("pub async fn {}<C>(\n", fn_name));
    code.push_str("    client: &C,\n");

    for param in &query.params {
        let rust_ty = param_type_to_rust(&param.ty);
        code.push_str(&format!("    {}: &{},\n", param.name, rust_ty));
    }

    let return_ty = if query.first {
        format!("Result<Option<{}>, QueryError>", struct_name)
    } else {
        format!("Result<Vec<{}>, QueryError>", struct_name)
    };

    code.push_str(&format!(
        ") -> {}\nwhere\n    C: tokio_postgres::GenericClient,\n{{\n",
        return_ty
    ));

    // Function body
    if let Some(raw_sql) = &query.raw_sql {
        // Raw SQL query
        generate_raw_query_body(query, raw_sql, code);
    } else {
        // Generated SQL
        generate_simple_query_body(query, code);
    }

    code.push_str("}\n");
}

fn generate_simple_query_body(query: &Query, code: &mut String) {
    let generated = generate_simple_sql(query);

    code.push_str(&format!(
        "    const SQL: &str = r#\"{}\"#;\n\n",
        generated.sql
    ));

    // Build params array
    let params: Vec<_> = generated
        .param_order
        .iter()
        .filter(|p| !p.starts_with("__literal_"))
        .collect();

    if params.is_empty() {
        code.push_str("    let rows = client.query(SQL, &[]).await?;\n");
    } else {
        code.push_str("    let rows = client.query(SQL, &[");
        for (i, param_name) in params.iter().enumerate() {
            if i > 0 {
                code.push_str(", ");
            }
            code.push_str(param_name);
        }
        code.push_str("]).await?;\n");
    }

    // Convert rows to structs
    if query.first {
        code.push_str("    match rows.into_iter().next() {\n");
        code.push_str("        Some(row) => Ok(Some(from_row(&row)?)),\n");
        code.push_str("        None => Ok(None),\n");
        code.push_str("    }\n");
    } else {
        code.push_str("    rows.iter().map(|row| Ok(from_row(row)?)).collect()\n");
    }
}

fn generate_raw_query_body(query: &Query, raw_sql: &str, code: &mut String) {
    // Clean up the raw SQL - remove leading/trailing whitespace per line
    let cleaned: String = raw_sql
        .lines()
        .map(|l| l.trim())
        .collect::<Vec<_>>()
        .join("\n");

    code.push_str(&format!(
        "    const SQL: &str = r#\"{}\"#;\n\n",
        cleaned.trim()
    ));

    // Build params
    if query.params.is_empty() {
        code.push_str("    let rows = client.query(SQL, &[]).await?;\n");
    } else {
        code.push_str("    let rows = client.query(SQL, &[");
        for (i, param) in query.params.iter().enumerate() {
            if i > 0 {
                code.push_str(", ");
            }
            code.push_str(&param.name);
        }
        code.push_str("]).await?;\n");
    }

    // Convert rows to structs
    if query.first {
        code.push_str("    match rows.into_iter().next() {\n");
        code.push_str("        Some(row) => Ok(Some(from_row(&row)?)),\n");
        code.push_str("        None => Ok(None),\n");
        code.push_str("    }\n");
    } else {
        code.push_str("    rows.iter().map(|row| Ok(from_row(row)?)).collect()\n");
    }
}

fn param_type_to_rust(ty: &ParamType) -> String {
    match ty {
        ParamType::String => "String".to_string(),
        ParamType::Int => "i64".to_string(),
        ParamType::Bool => "bool".to_string(),
        ParamType::Uuid => "Uuid".to_string(),
        ParamType::Decimal => "Decimal".to_string(),
        ParamType::Timestamp => "Timestamp".to_string(),
        ParamType::Optional(inner) => format!("Option<{}>", param_type_to_rust(inner)),
    }
}

fn to_pascal_case(s: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = true;

    for c in s.chars() {
        if c == '_' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }

    result
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();

    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parse::parse_query_file;

    #[test]
    fn test_generate_simple_query() {
        let source = r#"
AllProducts @query{
  from product
  select{ id, handle, status }
}
"#;
        let file = parse_query_file(source).unwrap();
        let code = generate_rust_code(&file);

        assert!(code.code.contains("pub struct AllProductsResult"));
        assert!(code.code.contains("pub async fn all_products"));
        assert!(code.code.contains("pub id: String"));
        assert!(code.code.contains("pub handle: String"));
        assert!(code.code.contains("#[derive(Debug, Clone, Facet)]"));
    }

    #[test]
    fn test_generate_query_with_params() {
        let source = r#"
ProductByHandle @query{
  params{ handle @string }
  from product
  where{ handle $handle }
  first true
  select{ id, handle }
}
"#;
        let file = parse_query_file(source).unwrap();
        let code = generate_rust_code(&file);

        assert!(code.code.contains("handle: &String"));
        assert!(code.code.contains("from_row"));
        assert!(code.code.contains("Ok(None)"));
    }

    #[test]
    fn test_generate_query_with_relation() {
        let source = r#"
ProductListing @query{
  from product
  select{
    id
    translation @rel{
      first true
      select{ title, description }
    }
  }
}
"#;
        let file = parse_query_file(source).unwrap();
        let code = generate_rust_code(&file);

        assert!(code.code.contains("pub translation: Option<Translation>"));
        assert!(code.code.contains("pub struct Translation"));
        assert!(code.code.contains("pub title: String"));
    }

    #[test]
    fn test_generate_raw_sql_query() {
        let source = r#"
TrendingProducts @query{
  params{
    locale @string
    days @int
  }
  sql <<SQL
    SELECT id, title FROM products WHERE locale = $1
  SQL
  returns{
    id @int
    title @string
  }
}
"#;
        let file = parse_query_file(source).unwrap();
        let code = generate_rust_code(&file);

        assert!(code.code.contains("locale: &String"));
        assert!(code.code.contains("days: &i64"));
        assert!(code.code.contains("pub id: i64"));
        assert!(code.code.contains("pub title: String"));
        assert!(code.code.contains("SELECT id, title FROM products"));
    }

    #[test]
    fn test_snake_case() {
        assert_eq!(to_snake_case("ProductListing"), "product_listing");
        assert_eq!(to_snake_case("AllProducts"), "all_products");
        assert_eq!(to_snake_case("ID"), "i_d");
    }

    #[test]
    fn test_pascal_case() {
        assert_eq!(to_pascal_case("translation"), "Translation");
        assert_eq!(to_pascal_case("product_variant"), "ProductVariant");
    }
}
