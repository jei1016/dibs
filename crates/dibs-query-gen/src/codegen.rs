//! Rust code generation from query AST.

use crate::ast::*;
use crate::sql::generate_simple_sql;

/// Generated Rust code for a query file.
#[derive(Debug, Clone)]
pub struct GeneratedCode {
    /// Full Rust source code.
    pub code: String,
}

/// Generate Rust code for a query file.
pub fn generate_rust_code(file: &QueryFile) -> GeneratedCode {
    let mut code = String::new();

    // Imports
    code.push_str("// Generated by dibs-query-gen. Do not edit.\n\n");
    code.push_str("use sqlx::FromRow;\n\n");

    for query in &file.queries {
        generate_query_code(query, &mut code);
    }

    GeneratedCode { code }
}

fn generate_query_code(query: &Query, code: &mut String) {
    // Generate result struct
    let struct_name = format!("{}Result", query.name);
    generate_result_struct(query, &struct_name, &query.select, code);

    code.push('\n');

    // Generate query function
    generate_query_function(query, &struct_name, code);

    code.push('\n');
}

fn generate_result_struct(query: &Query, struct_name: &str, fields: &[Field], code: &mut String) {
    code.push_str("#[derive(Debug, Clone, FromRow)]\n");
    code.push_str(&format!("pub struct {} {{\n", struct_name));

    if query.is_raw() {
        // Raw SQL - use returns declaration
        for ret in &query.returns {
            let rust_ty = param_type_to_rust(&ret.ty);
            code.push_str(&format!("    pub {}: {},\n", ret.name, rust_ty));
        }
    } else {
        // Regular query - use select fields
        for field in fields {
            match field {
                Field::Column { name, .. } => {
                    // TODO: Look up actual type from schema
                    // For now, use String as placeholder
                    code.push_str(&format!("    pub {}: String,\n", name));
                }
                Field::Relation {
                    name,
                    first,
                    select,
                    ..
                } => {
                    // Nested struct for relation
                    let nested_name = to_pascal_case(name);
                    let ty = if *first {
                        format!("Option<{}>", nested_name)
                    } else {
                        format!("Vec<{}>", nested_name)
                    };
                    code.push_str(&format!("    pub {}: {},\n", name, ty));
                    // We'll generate nested struct after the parent
                    let _ = select; // TODO: generate nested struct
                }
                Field::Count { name, .. } => {
                    code.push_str(&format!("    pub {}: i64,\n", name));
                }
            }
        }
    }

    code.push_str("}\n");

    // Generate nested structs for relations
    if !query.is_raw() {
        for field in fields {
            if let Field::Relation { name, select, .. } = field {
                let nested_name = to_pascal_case(name);
                code.push('\n');
                code.push_str("#[derive(Debug, Clone, FromRow)]\n");
                code.push_str(&format!("pub struct {} {{\n", nested_name));
                for f in select {
                    if let Field::Column { name, .. } = f {
                        code.push_str(&format!("    pub {}: String,\n", name));
                    }
                }
                code.push_str("}\n");
            }
        }
    }
}

fn generate_query_function(query: &Query, struct_name: &str, code: &mut String) {
    let fn_name = to_snake_case(&query.name);

    // Function signature
    code.push_str(&format!("pub async fn {}(\n", fn_name));
    code.push_str("    pool: &sqlx::PgPool,\n");

    for param in &query.params {
        let rust_ty = param_type_to_rust(&param.ty);
        code.push_str(&format!("    {}: {},\n", param.name, rust_ty));
    }

    let return_ty = if query.first {
        format!("Result<Option<{}>, sqlx::Error>", struct_name)
    } else {
        format!("Result<Vec<{}>, sqlx::Error>", struct_name)
    };

    code.push_str(&format!(") -> {} {{\n", return_ty));

    // Function body
    if let Some(raw_sql) = &query.raw_sql {
        // Raw SQL query
        generate_raw_query_body(query, raw_sql, code);
    } else {
        // Generated SQL
        generate_simple_query_body(query, code);
    }

    code.push_str("}\n");
}

fn generate_simple_query_body(query: &Query, code: &mut String) {
    let generated = generate_simple_sql(query);

    code.push_str(&format!("    const SQL: &str = r#\"{}\"#;\n\n", generated.sql));

    // Build query
    code.push_str("    sqlx::query_as(SQL)\n");

    // Bind parameters in order
    for param_name in &generated.param_order {
        if param_name.starts_with("__literal_") {
            // Skip literals for now - they'd need special handling
            continue;
        }
        code.push_str(&format!("        .bind(&{})\n", param_name));
    }

    // Execute
    if query.first {
        code.push_str("        .fetch_optional(pool)\n");
    } else {
        code.push_str("        .fetch_all(pool)\n");
    }
    code.push_str("        .await\n");
}

fn generate_raw_query_body(query: &Query, raw_sql: &str, code: &mut String) {
    // Clean up the raw SQL - remove leading/trailing whitespace per line
    let cleaned: String = raw_sql
        .lines()
        .map(|l| l.trim())
        .collect::<Vec<_>>()
        .join("\n");

    code.push_str(&format!("    const SQL: &str = r#\"{}\"#;\n\n", cleaned.trim()));

    code.push_str("    sqlx::query_as(SQL)\n");

    // Bind parameters in order (assume $1, $2, etc. match param order)
    for param in &query.params {
        code.push_str(&format!("        .bind(&{})\n", param.name));
    }

    if query.first {
        code.push_str("        .fetch_optional(pool)\n");
    } else {
        code.push_str("        .fetch_all(pool)\n");
    }
    code.push_str("        .await\n");
}

fn param_type_to_rust(ty: &ParamType) -> String {
    match ty {
        ParamType::String => "String".to_string(),
        ParamType::Int => "i64".to_string(),
        ParamType::Bool => "bool".to_string(),
        ParamType::Uuid => "uuid::Uuid".to_string(),
        ParamType::Decimal => "rust_decimal::Decimal".to_string(),
        ParamType::Timestamp => "chrono::DateTime<chrono::Utc>".to_string(),
        ParamType::Optional(inner) => format!("Option<{}>", param_type_to_rust(inner)),
    }
}

fn to_pascal_case(s: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = true;

    for c in s.chars() {
        if c == '_' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }

    result
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();

    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parse::parse_query_file;

    #[test]
    fn test_generate_simple_query() {
        let source = r#"
AllProducts @query{
  from product
  select{ id, handle, status }
}
"#;
        let file = parse_query_file(source).unwrap();
        let code = generate_rust_code(&file);

        assert!(code.code.contains("pub struct AllProductsResult"));
        assert!(code.code.contains("pub async fn all_products("));
        assert!(code.code.contains("pub id: String"));
        assert!(code.code.contains("pub handle: String"));
    }

    #[test]
    fn test_generate_query_with_params() {
        let source = r#"
ProductByHandle @query{
  params{ handle @string }
  from product
  where{ handle $handle }
  first true
  select{ id, handle }
}
"#;
        let file = parse_query_file(source).unwrap();
        let code = generate_rust_code(&file);

        assert!(code.code.contains("handle: String,"));
        assert!(code.code.contains("fetch_optional"));
        assert!(code.code.contains(".bind(&handle)"));
    }

    #[test]
    fn test_generate_query_with_relation() {
        let source = r#"
ProductListing @query{
  from product
  select{
    id
    translation @rel{
      first true
      select{ title, description }
    }
  }
}
"#;
        let file = parse_query_file(source).unwrap();
        let code = generate_rust_code(&file);

        assert!(code.code.contains("pub translation: Option<Translation>"));
        assert!(code.code.contains("pub struct Translation"));
        assert!(code.code.contains("pub title: String"));
    }

    #[test]
    fn test_generate_raw_sql_query() {
        let source = r#"
TrendingProducts @query{
  params{
    locale @string
    days @int
  }
  sql <<SQL
    SELECT id, title FROM products WHERE locale = $1
  SQL
  returns{
    id @int
    title @string
  }
}
"#;
        let file = parse_query_file(source).unwrap();
        let code = generate_rust_code(&file);

        assert!(code.code.contains("locale: String"));
        assert!(code.code.contains("days: i64"));
        assert!(code.code.contains("pub id: i64"));
        assert!(code.code.contains("pub title: String"));
        assert!(code.code.contains("SELECT id, title FROM products"));
    }

    #[test]
    fn test_snake_case() {
        assert_eq!(to_snake_case("ProductListing"), "product_listing");
        assert_eq!(to_snake_case("AllProducts"), "all_products");
        assert_eq!(to_snake_case("ID"), "i_d");
    }

    #[test]
    fn test_pascal_case() {
        assert_eq!(to_pascal_case("translation"), "Translation");
        assert_eq!(to_pascal_case("product_variant"), "ProductVariant");
    }
}
