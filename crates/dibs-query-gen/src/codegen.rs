//! Rust code generation from query AST using the `codegen` crate.

use crate::ast::*;
use crate::planner::PlannerSchema;
use crate::sql::{generate_simple_sql, generate_sql_with_joins};
use codegen::{Function, Scope, Struct};
use std::collections::HashMap;

/// Generated Rust code for a query file.
#[derive(Debug, Clone)]
pub struct GeneratedCode {
    /// Full Rust source code.
    pub code: String,
}

/// Schema information for code generation.
///
/// This provides type information for columns, allowing the codegen
/// to emit correctly-typed result structs.
#[derive(Debug, Clone, Default)]
pub struct SchemaInfo {
    /// Map of table name -> column info.
    pub tables: HashMap<String, TableInfo>,
}

/// Information about a single table.
#[derive(Debug, Clone, Default)]
pub struct TableInfo {
    /// Map of column name -> Rust type string.
    pub columns: HashMap<String, ColumnInfo>,
}

/// Information about a single column.
#[derive(Debug, Clone)]
pub struct ColumnInfo {
    /// Rust type name (e.g., "i64", "String", "bool").
    pub rust_type: String,
    /// Whether the column is nullable (`Option<T>`).
    pub nullable: bool,
}

impl SchemaInfo {
    /// Create a new empty schema.
    pub fn new() -> Self {
        Self::default()
    }

    /// Look up the Rust type for a column.
    pub fn column_type(&self, table: &str, column: &str) -> Option<String> {
        let table_info = self.tables.get(table)?;
        let col_info = table_info.columns.get(column)?;
        if col_info.nullable {
            Some(format!("Option<{}>", col_info.rust_type))
        } else {
            Some(col_info.rust_type.clone())
        }
    }
}

/// Context for code generation.
struct CodegenContext<'a> {
    schema: &'a SchemaInfo,
    planner_schema: Option<&'a PlannerSchema>,
}

/// Generate Rust code for a query file.
pub fn generate_rust_code(file: &QueryFile) -> GeneratedCode {
    generate_rust_code_with_schema(file, &SchemaInfo::default())
}

/// Generate Rust code for a query file with schema information.
pub fn generate_rust_code_with_schema(file: &QueryFile, schema: &SchemaInfo) -> GeneratedCode {
    generate_rust_code_with_planner(file, schema, None)
}

/// Generate Rust code for a query file with full schema and planner info.
///
/// When `planner_schema` is provided, queries with relations will generate
/// JOINs and proper result assembly code.
pub fn generate_rust_code_with_planner(
    file: &QueryFile,
    schema: &SchemaInfo,
    planner_schema: Option<&PlannerSchema>,
) -> GeneratedCode {
    let ctx = CodegenContext {
        schema,
        planner_schema,
    };

    let mut scope = Scope::new();

    // Add file header as raw code
    scope.raw("// Generated by dibs-query-gen. Do not edit.");
    scope.raw("");

    // Imports
    scope.import("dibs_runtime::prelude", "*");
    scope.import("dibs_runtime", "tokio_postgres");

    for query in &file.queries {
        generate_query_code(&ctx, query, &mut scope);
    }

    GeneratedCode {
        code: scope.to_string(),
    }
}

fn generate_query_code(ctx: &CodegenContext, query: &Query, scope: &mut Scope) {
    let struct_name = format!("{}Result", query.name);

    // Generate result struct(s)
    generate_result_struct(ctx, query, &struct_name, &query.from, &query.select, scope);

    // Generate query function
    generate_query_function(ctx, query, &struct_name, scope);
}

fn generate_result_struct(
    ctx: &CodegenContext,
    query: &Query,
    struct_name: &str,
    table: &str,
    fields: &[Field],
    scope: &mut Scope,
) {
    let mut st = Struct::new(struct_name);
    st.vis("pub");
    st.derive("Debug");
    st.derive("Clone");
    st.derive("Facet");
    st.attr("facet(crate = dibs_runtime::facet)");

    if query.is_raw() {
        // Raw SQL - use returns declaration
        for ret in &query.returns {
            let rust_ty = param_type_to_rust(&ret.ty);
            st.field(&format!("pub {}", ret.name), &rust_ty);
        }
    } else {
        // Regular query - use select fields
        for field in fields {
            match field {
                Field::Column { name, .. } => {
                    let rust_ty = ctx
                        .schema
                        .column_type(table, name)
                        .unwrap_or_else(|| "String".to_string());
                    st.field(&format!("pub {}", name), &rust_ty);
                }
                Field::Relation { name, first, .. } => {
                    let nested_name = to_pascal_case(name);
                    let ty = if *first {
                        format!("Option<{}>", nested_name)
                    } else {
                        format!("Vec<{}>", nested_name)
                    };
                    st.field(&format!("pub {}", name), &ty);
                }
                Field::Count { name, .. } => {
                    st.field(&format!("pub {}", name), "i64");
                }
            }
        }
    }

    scope.push_struct(st);

    // Generate nested structs for relations
    if !query.is_raw() {
        for field in fields {
            if let Field::Relation {
                name, select, from, ..
            } = field
            {
                let nested_name = to_pascal_case(name);
                let rel_table = from.as_deref().unwrap_or(name);

                let mut nested_st = Struct::new(&nested_name);
                nested_st.vis("pub");
                nested_st.derive("Debug");
                nested_st.derive("Clone");
                nested_st.derive("Facet");
                nested_st.attr("facet(crate = dibs_runtime::facet)");

                for f in select {
                    if let Field::Column { name: col_name, .. } = f {
                        let rust_ty = ctx
                            .schema
                            .column_type(rel_table, col_name)
                            .unwrap_or_else(|| "String".to_string());
                        nested_st.field(&format!("pub {}", col_name), &rust_ty);
                    }
                }

                scope.push_struct(nested_st);
            }
        }
    }
}

fn generate_query_function(
    ctx: &CodegenContext,
    query: &Query,
    struct_name: &str,
    scope: &mut Scope,
) {
    let fn_name = to_snake_case(&query.name);

    let return_ty = if query.first {
        format!("Result<Option<{}>, QueryError>", struct_name)
    } else {
        format!("Result<Vec<{}>, QueryError>", struct_name)
    };

    let mut func = Function::new(&fn_name);
    func.vis("pub");
    func.set_async(true);
    func.generic("C");
    func.arg("client", "&C");

    for param in &query.params {
        let rust_ty = param_type_to_rust(&param.ty);
        func.arg(&param.name, format!("&{}", rust_ty));
    }

    func.ret(&return_ty);
    func.bound("C", "tokio_postgres::GenericClient");

    // Generate function body
    let body = if let Some(raw_sql) = &query.raw_sql {
        generate_raw_query_body(query, raw_sql)
    } else {
        // Use planner path if query has relations or COUNT fields
        let needs_planner = query.select.iter().any(|f| {
            matches!(f, Field::Relation { .. }) || matches!(f, Field::Count { .. })
        });

        if needs_planner && ctx.planner_schema.is_some() {
            generate_join_query_body(ctx, query, struct_name)
        } else {
            generate_simple_query_body(query)
        }
    };

    func.line(body);
    scope.push_fn(func);
}

/// Check if query has any Vec (has-many) relations.
fn has_vec_relations(query: &Query) -> bool {
    query
        .select
        .iter()
        .any(|f| matches!(f, Field::Relation { first: false, .. }))
}

/// Generate query body for queries with JOINs.
fn generate_join_query_body(ctx: &CodegenContext, query: &Query, struct_name: &str) -> String {
    let planner_schema = ctx.planner_schema.unwrap();

    let generated = match generate_sql_with_joins(query, planner_schema) {
        Ok(g) => g,
        Err(e) => {
            return format!(
                "// Warning: JOIN planning failed: {}\n{}",
                e,
                generate_simple_query_body(query)
            );
        }
    };

    let plan = generated.plan.as_ref().unwrap();

    let mut body = String::new();

    // SQL constant
    body.push_str(&format!("const SQL: &str = r#\"{}\"#;\n\n", generated.sql));

    // Build params array
    let params: Vec<_> = generated
        .param_order
        .iter()
        .filter(|p| !p.starts_with("__literal_"))
        .collect();

    if params.is_empty() {
        body.push_str("let rows = client.query(SQL, &[]).await?;\n\n");
    } else {
        body.push_str("let rows = client.query(SQL, &[");
        for (i, param_name) in params.iter().enumerate() {
            if i > 0 {
                body.push_str(", ");
            }
            body.push_str(param_name);
        }
        body.push_str("]).await?;\n\n");
    }

    // Check if we have Vec relations - if so, use HashMap-based grouping
    if has_vec_relations(query) {
        body.push_str(&generate_vec_relation_assembly(ctx, query, struct_name, plan));
    } else {
        body.push_str(&generate_option_relation_assembly(ctx, query, struct_name));
    }

    body
}

/// Generate assembly code for queries with Vec (has-many) relations.
fn generate_vec_relation_assembly(
    ctx: &CodegenContext,
    query: &Query,
    struct_name: &str,
    plan: &crate::planner::QueryPlan,
) -> String {
    let mut body = String::new();

    // Find the parent key column from the first Vec relation
    let parent_key_column = plan
        .result_mapping
        .relations
        .values()
        .find_map(|r| r.parent_key_column.as_ref())
        .cloned()
        .unwrap_or_else(|| "id".to_string());

    let parent_key_type = ctx
        .schema
        .column_type(&query.from, &parent_key_column)
        .unwrap_or_else(|| "i64".to_string());

    body.push_str("// Group rows by parent ID for has-many relations\n");
    body.push_str(&format!(
        "let mut grouped: std::collections::HashMap<{}, {}> = std::collections::HashMap::new();\n\n",
        parent_key_type, struct_name
    ));

    body.push_str("for row in rows.iter() {\n");
    body.push_str(&format!(
        "    let parent_id: {} = row.get(\"{}\");\n\n",
        parent_key_type, parent_key_column
    ));

    body.push_str("    let entry = grouped.entry(parent_id.clone()).or_insert_with(|| {\n");
    body.push_str(&format!("        {} {{\n", struct_name));

    for field in &query.select {
        match field {
            Field::Column { name, .. } => {
                body.push_str(&format!("            {}: row.get(\"{}\"),\n", name, name));
            }
            Field::Relation {
                name,
                first,
                from,
                select,
                ..
            } => {
                if *first {
                    let rel_table = from.as_deref().unwrap_or(name);
                    let nested_name = to_pascal_case(name);
                    let first_col = get_first_column(select);
                    let first_alias = format!("{}_{}", name, first_col);

                    body.push_str(&format!(
                        "            {}: row.get::<_, Option<_>>(\"{}\").map(|{}_val| {} {{\n",
                        name, first_alias, first_alias, nested_name
                    ));
                    for f in select {
                        if let Field::Column { name: col_name, .. } = f {
                            let alias = format!("{}_{}", name, col_name);
                            let rust_ty = ctx
                                .schema
                                .column_type(rel_table, col_name)
                                .unwrap_or_else(|| "String".to_string());
                            let value_expr = if rust_ty.starts_with("Option<") {
                                format!("row.get(\"{}\")", alias)
                            } else if alias == first_alias {
                                format!("{}_val", first_alias)
                            } else {
                                format!("row.get::<_, Option<_>>(\"{}\").unwrap()", alias)
                            };
                            body.push_str(&format!("                {}: {},\n", col_name, value_expr));
                        }
                    }
                    body.push_str("            }),\n");
                } else {
                    body.push_str(&format!("            {}: vec![],\n", name));
                }
            }
            Field::Count { name, .. } => {
                body.push_str(&format!("            {}: row.get(\"{}\"),\n", name, name));
            }
        }
    }

    body.push_str("        }\n");
    body.push_str("    });\n\n");

    // Append to Vec relations
    for field in &query.select {
        if let Field::Relation {
            name,
            first: false,
            select,
            from,
            ..
        } = field
        {
            let rel_table = from.as_deref().unwrap_or(name);
            let nested_name = to_pascal_case(name);
            let first_col = get_first_column(select);
            let first_alias = format!("{}_{}", name, first_col);

            body.push_str(&format!(
                "    // Append {} if present (LEFT JOIN may have NULL)\n",
                name
            ));
            body.push_str(&format!(
                "    if let Some({}_val) = row.get::<_, Option<_>>(\"{}\") {{\n",
                first_alias, first_alias
            ));
            body.push_str(&format!(
                "        entry.{}.push({} {{\n",
                name, nested_name
            ));
            for f in select {
                if let Field::Column { name: col_name, .. } = f {
                    let alias = format!("{}_{}", name, col_name);
                    let rust_ty = ctx
                        .schema
                        .column_type(rel_table, col_name)
                        .unwrap_or_else(|| "String".to_string());
                    let value_expr = if rust_ty.starts_with("Option<") {
                        format!("row.get(\"{}\")", alias)
                    } else if alias == first_alias {
                        format!("{}_val", first_alias)
                    } else {
                        format!("row.get::<_, Option<_>>(\"{}\").unwrap()", alias)
                    };
                    body.push_str(&format!("            {}: {},\n", col_name, value_expr));
                }
            }
            body.push_str("        });\n");
            body.push_str("    }\n");
        }
    }

    body.push_str("}\n\n");

    if query.first {
        body.push_str("Ok(grouped.into_values().next())");
    } else {
        body.push_str("Ok(grouped.into_values().collect())");
    }

    body
}

/// Generate assembly code for queries with only Option relations.
fn generate_option_relation_assembly(
    ctx: &CodegenContext,
    query: &Query,
    struct_name: &str,
) -> String {
    let mut body = String::new();

    body.push_str("// Assemble flat rows into nested structs\n");
    body.push_str("let results: Result<Vec<_>, QueryError> = rows.iter().map(|row| {\n");

    // Extract base table columns and COUNT fields
    for field in &query.select {
        match field {
            Field::Column { name, .. } => {
                let rust_ty = ctx
                    .schema
                    .column_type(&query.from, name)
                    .unwrap_or_else(|| "String".to_string());
                body.push_str(&format!(
                    "    let {}: {} = row.get(\"{}\");\n",
                    name, rust_ty, name
                ));
            }
            Field::Count { name, .. } => {
                body.push_str(&format!(
                    "    let {}: i64 = row.get(\"{}\");\n",
                    name, name
                ));
            }
            _ => {}
        }
    }

    // Extract relation columns and build nested structs
    for field in &query.select {
        if let Field::Relation {
            name,
            first,
            select,
            from,
            ..
        } = field
        {
            let rel_table = from.as_deref().unwrap_or(name);
            let nested_name = to_pascal_case(name);

            for f in select {
                if let Field::Column { name: col_name, .. } = f {
                    let rust_ty = ctx
                        .schema
                        .column_type(rel_table, col_name)
                        .unwrap_or_else(|| "String".to_string());
                    let alias = format!("{}_{}", name, col_name);
                    let wrapped_ty = if rust_ty.starts_with("Option<") {
                        rust_ty.clone()
                    } else {
                        format!("Option<{}>", rust_ty)
                    };
                    body.push_str(&format!(
                        "    let {}: {} = row.get(\"{}\");\n",
                        alias, wrapped_ty, alias
                    ));
                }
            }

            if *first {
                let first_col = get_first_column(select);
                let first_alias = format!("{}_{}", name, first_col);

                body.push_str(&format!(
                    "    let {} = {}.map(|{}_val| {} {{\n",
                    name, first_alias, first_alias, nested_name
                ));
                for f in select {
                    if let Field::Column { name: col_name, .. } = f {
                        let alias = format!("{}_{}", name, col_name);
                        let rust_ty = ctx
                            .schema
                            .column_type(rel_table, col_name)
                            .unwrap_or_else(|| "String".to_string());
                        let value_expr = if rust_ty.starts_with("Option<") {
                            alias.clone()
                        } else if alias == first_alias {
                            format!("{}_val", first_alias)
                        } else {
                            format!("{}.unwrap()", alias)
                        };
                        body.push_str(&format!("        {}: {},\n", col_name, value_expr));
                    }
                }
                body.push_str("    });\n");
            }
        }
    }

    // Build the result struct
    body.push_str(&format!("    Ok({} {{\n", struct_name));
    for field in &query.select {
        match field {
            Field::Column { name, .. } | Field::Relation { name, .. } | Field::Count { name, .. } => {
                body.push_str(&format!("        {},\n", name));
            }
        }
    }
    body.push_str("    })\n");
    body.push_str("}).collect();\n\n");

    if query.first {
        body.push_str("Ok(results?.into_iter().next())");
    } else {
        body.push_str("results");
    }

    body
}

fn generate_simple_query_body(query: &Query) -> String {
    let generated = generate_simple_sql(query);
    let mut body = String::new();

    body.push_str(&format!("const SQL: &str = r#\"{}\"#;\n\n", generated.sql));

    let params: Vec<_> = generated
        .param_order
        .iter()
        .filter(|p| !p.starts_with("__literal_"))
        .collect();

    if params.is_empty() {
        body.push_str("let rows = client.query(SQL, &[]).await?;\n");
    } else {
        body.push_str("let rows = client.query(SQL, &[");
        for (i, param_name) in params.iter().enumerate() {
            if i > 0 {
                body.push_str(", ");
            }
            body.push_str(param_name);
        }
        body.push_str("]).await?;\n");
    }

    if query.first {
        body.push_str("match rows.into_iter().next() {\n");
        body.push_str("    Some(row) => Ok(Some(from_row(&row)?)),\n");
        body.push_str("    None => Ok(None),\n");
        body.push('}');
    } else {
        body.push_str("rows.iter().map(|row| Ok(from_row(row)?)).collect()");
    }

    body
}

fn generate_raw_query_body(query: &Query, raw_sql: &str) -> String {
    let cleaned: String = raw_sql
        .lines()
        .map(|l| l.trim())
        .collect::<Vec<_>>()
        .join("\n");

    let mut body = String::new();

    body.push_str(&format!("const SQL: &str = r#\"{}\"#;\n\n", cleaned.trim()));

    if query.params.is_empty() {
        body.push_str("let rows = client.query(SQL, &[]).await?;\n");
    } else {
        body.push_str("let rows = client.query(SQL, &[");
        for (i, param) in query.params.iter().enumerate() {
            if i > 0 {
                body.push_str(", ");
            }
            body.push_str(&param.name);
        }
        body.push_str("]).await?;\n");
    }

    if query.first {
        body.push_str("match rows.into_iter().next() {\n");
        body.push_str("    Some(row) => Ok(Some(from_row(&row)?)),\n");
        body.push_str("    None => Ok(None),\n");
        body.push('}');
    } else {
        body.push_str("rows.iter().map(|row| Ok(from_row(row)?)).collect()");
    }

    body
}

fn get_first_column(select: &[Field]) -> String {
    select
        .iter()
        .find_map(|f| {
            if let Field::Column { name, .. } = f {
                Some(name.clone())
            } else {
                None
            }
        })
        .unwrap_or_default()
}

fn param_type_to_rust(ty: &ParamType) -> String {
    match ty {
        ParamType::String => "String".to_string(),
        ParamType::Int => "i64".to_string(),
        ParamType::Bool => "bool".to_string(),
        ParamType::Uuid => "Uuid".to_string(),
        ParamType::Decimal => "Decimal".to_string(),
        ParamType::Timestamp => "Timestamp".to_string(),
        ParamType::Optional(inner) => format!("Option<{}>", param_type_to_rust(inner)),
    }
}

fn to_pascal_case(s: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = true;

    for c in s.chars() {
        if c == '_' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }

    result
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();

    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parse::parse_query_file;

    #[test]
    fn test_generate_simple_query() {
        let source = r#"
AllProducts @query{
  from product
  select{ id, handle, status }
}
"#;
        let file = parse_query_file(source).unwrap();
        let code = generate_rust_code(&file);

        assert!(code.code.contains("pub struct AllProductsResult"));
        assert!(code.code.contains("pub async fn all_products"));
        assert!(code.code.contains("pub id: String"));
        assert!(code.code.contains("pub handle: String"));
        assert!(code.code.contains("#[derive(Debug, Clone, Facet)]"));
    }

    #[test]
    fn test_generate_query_with_params() {
        let source = r#"
ProductByHandle @query{
  params{ handle @string }
  from product
  where{ handle $handle }
  first true
  select{ id, handle }
}
"#;
        let file = parse_query_file(source).unwrap();
        let code = generate_rust_code(&file);

        assert!(code.code.contains("handle: &String"));
        assert!(code.code.contains("from_row"));
        assert!(code.code.contains("Ok(None)"));
    }

    #[test]
    fn test_generate_query_with_relation() {
        let source = r#"
ProductListing @query{
  from product
  select{
    id
    translation @rel{
      first true
      select{ title, description }
    }
  }
}
"#;
        let file = parse_query_file(source).unwrap();
        let code = generate_rust_code(&file);

        assert!(code.code.contains("pub translation: Option<Translation>"));
        assert!(code.code.contains("pub struct Translation"));
        assert!(code.code.contains("pub title: String"));
    }

    #[test]
    fn test_generate_raw_sql_query() {
        let source = r#"
TrendingProducts @query{
  params{
    locale @string
    days @int
  }
  sql <<SQL
    SELECT id, title FROM products WHERE locale = $1
  SQL
  returns{
    id @int
    title @string
  }
}
"#;
        let file = parse_query_file(source).unwrap();
        let code = generate_rust_code(&file);

        assert!(code.code.contains("locale: &String"));
        assert!(code.code.contains("days: &i64"));
        assert!(code.code.contains("pub id: i64"));
        assert!(code.code.contains("pub title: String"));
        assert!(code.code.contains("SELECT id, title FROM products"));
    }

    #[test]
    fn test_snake_case() {
        assert_eq!(to_snake_case("ProductListing"), "product_listing");
        assert_eq!(to_snake_case("AllProducts"), "all_products");
        assert_eq!(to_snake_case("ID"), "i_d");
    }

    #[test]
    fn test_pascal_case() {
        assert_eq!(to_pascal_case("translation"), "Translation");
        assert_eq!(to_pascal_case("product_variant"), "ProductVariant");
    }

    #[test]
    fn test_generate_join_query() {
        use crate::planner::{PlannerForeignKey, PlannerSchema, PlannerTable};

        let source = r#"
ProductWithTranslation @query{
  params{ handle @string }
  from product
  where{ handle $handle }
  first true
  select{
    id
    handle
    translation @rel{
      from product_translation
      first true
      select{ title, description }
    }
  }
}
"#;
        let file = parse_query_file(source).unwrap();

        let mut schema = SchemaInfo::default();
        let mut product_cols = HashMap::new();
        product_cols.insert(
            "id".to_string(),
            ColumnInfo {
                rust_type: "i64".to_string(),
                nullable: false,
            },
        );
        product_cols.insert(
            "handle".to_string(),
            ColumnInfo {
                rust_type: "String".to_string(),
                nullable: false,
            },
        );
        schema.tables.insert(
            "product".to_string(),
            TableInfo {
                columns: product_cols,
            },
        );

        let mut translation_cols = HashMap::new();
        translation_cols.insert(
            "title".to_string(),
            ColumnInfo {
                rust_type: "String".to_string(),
                nullable: false,
            },
        );
        translation_cols.insert(
            "description".to_string(),
            ColumnInfo {
                rust_type: "String".to_string(),
                nullable: true,
            },
        );
        schema.tables.insert(
            "product_translation".to_string(),
            TableInfo {
                columns: translation_cols,
            },
        );

        let mut planner_schema = PlannerSchema::default();
        planner_schema.tables.insert(
            "product".to_string(),
            PlannerTable {
                name: "product".to_string(),
                columns: vec!["id".to_string(), "handle".to_string()],
                foreign_keys: vec![],
            },
        );
        planner_schema.tables.insert(
            "product_translation".to_string(),
            PlannerTable {
                name: "product_translation".to_string(),
                columns: vec![
                    "id".to_string(),
                    "product_id".to_string(),
                    "title".to_string(),
                    "description".to_string(),
                ],
                foreign_keys: vec![PlannerForeignKey {
                    columns: vec!["product_id".to_string()],
                    references_table: "product".to_string(),
                    references_columns: vec!["id".to_string()],
                }],
            },
        );

        let code = generate_rust_code_with_planner(&file, &schema, Some(&planner_schema));

        assert!(
            code.code
                .contains("pub struct ProductWithTranslationResult")
        );
        assert!(code.code.contains("pub id: i64"));
        assert!(code.code.contains("pub handle: String"));
        assert!(code.code.contains("pub translation: Option<Translation>"));
        assert!(code.code.contains("pub struct Translation"));
        assert!(code.code.contains("LEFT JOIN"));
        assert!(code.code.contains("product_translation"));
        assert!(code.code.contains("translation_title"));
        assert!(code.code.contains("translation_description"));
        assert!(
            code.code
                .contains(".map(|translation_title_val| Translation")
        );
        assert!(code.code.contains("title: translation_title_val"));
    }

    #[facet_testhelpers::test]
    fn test_generate_vec_relation_query() {
        use crate::planner::{PlannerForeignKey, PlannerSchema, PlannerTable};

        let source = r#"
ProductWithVariants @query{
  from product
  select{
    id
    handle
    variants @rel{
      from product_variant
      select{ id, sku }
    }
  }
}
"#;
        let file = parse_query_file(source).unwrap();

        let mut schema = SchemaInfo::default();
        let mut product_cols = HashMap::new();
        product_cols.insert(
            "id".to_string(),
            ColumnInfo {
                rust_type: "i64".to_string(),
                nullable: false,
            },
        );
        product_cols.insert(
            "handle".to_string(),
            ColumnInfo {
                rust_type: "String".to_string(),
                nullable: false,
            },
        );
        schema.tables.insert(
            "product".to_string(),
            TableInfo {
                columns: product_cols,
            },
        );

        let mut variant_cols = HashMap::new();
        variant_cols.insert(
            "id".to_string(),
            ColumnInfo {
                rust_type: "i64".to_string(),
                nullable: false,
            },
        );
        variant_cols.insert(
            "sku".to_string(),
            ColumnInfo {
                rust_type: "String".to_string(),
                nullable: false,
            },
        );
        schema.tables.insert(
            "product_variant".to_string(),
            TableInfo {
                columns: variant_cols,
            },
        );

        let mut planner_schema = PlannerSchema::default();
        planner_schema.tables.insert(
            "product".to_string(),
            PlannerTable {
                name: "product".to_string(),
                columns: vec!["id".to_string(), "handle".to_string()],
                foreign_keys: vec![],
            },
        );
        planner_schema.tables.insert(
            "product_variant".to_string(),
            PlannerTable {
                name: "product_variant".to_string(),
                columns: vec![
                    "id".to_string(),
                    "product_id".to_string(),
                    "sku".to_string(),
                ],
                foreign_keys: vec![PlannerForeignKey {
                    columns: vec!["product_id".to_string()],
                    references_table: "product".to_string(),
                    references_columns: vec!["id".to_string()],
                }],
            },
        );

        let code = generate_rust_code_with_planner(&file, &schema, Some(&planner_schema));

        tracing::info!("Generated code:\n{}", code.code);

        assert!(
            code.code.contains("pub struct ProductWithVariantsResult"),
            "Should generate result struct"
        );
        assert!(code.code.contains("pub id: i64"), "Should have id field");
        assert!(
            code.code.contains("pub handle: String"),
            "Should have handle field"
        );
        assert!(
            code.code.contains("pub variants: Vec<Variants>"),
            "Should have Vec variants field"
        );
        assert!(
            code.code.contains("pub struct Variants"),
            "Should generate nested Variants struct"
        );
        assert!(code.code.contains("LEFT JOIN"), "Should use LEFT JOIN");
        assert!(
            code.code.contains("product_variant"),
            "Should join product_variant"
        );
        assert!(
            code.code.contains("HashMap"),
            "Should use HashMap for grouping"
        );
        assert!(
            code.code.contains("grouped.entry"),
            "Should use entry API for grouping"
        );
        assert!(
            code.code.contains(".push("),
            "Should push to Vec relation"
        );
        assert!(
            code.code.contains("variants: vec![]"),
            "Should initialize Vec as empty"
        );
        assert!(
            code.code.contains("entry.variants.push"),
            "Should append to variants"
        );
    }

    #[facet_testhelpers::test]
    fn test_generate_count_query() {
        use crate::planner::{PlannerForeignKey, PlannerSchema, PlannerTable};

        let source = r#"
ProductWithVariantCount @query{
  from product
  select{
    id
    handle
    variant_count @count(product_variant)
  }
}
"#;
        let file = parse_query_file(source).unwrap();

        let mut schema = SchemaInfo::default();
        let mut product_cols = HashMap::new();
        product_cols.insert(
            "id".to_string(),
            ColumnInfo {
                rust_type: "i64".to_string(),
                nullable: false,
            },
        );
        product_cols.insert(
            "handle".to_string(),
            ColumnInfo {
                rust_type: "String".to_string(),
                nullable: false,
            },
        );
        schema.tables.insert(
            "product".to_string(),
            TableInfo {
                columns: product_cols,
            },
        );

        let mut planner_schema = PlannerSchema::default();
        planner_schema.tables.insert(
            "product".to_string(),
            PlannerTable {
                name: "product".to_string(),
                columns: vec!["id".to_string(), "handle".to_string()],
                foreign_keys: vec![],
            },
        );
        planner_schema.tables.insert(
            "product_variant".to_string(),
            PlannerTable {
                name: "product_variant".to_string(),
                columns: vec![
                    "id".to_string(),
                    "product_id".to_string(),
                    "sku".to_string(),
                ],
                foreign_keys: vec![PlannerForeignKey {
                    columns: vec!["product_id".to_string()],
                    references_table: "product".to_string(),
                    references_columns: vec!["id".to_string()],
                }],
            },
        );

        let code = generate_rust_code_with_planner(&file, &schema, Some(&planner_schema));

        tracing::info!("Generated code:\n{}", code.code);

        assert!(
            code.code.contains("pub struct ProductWithVariantCountResult"),
            "Should generate result struct"
        );
        assert!(
            code.code.contains("pub variant_count: i64"),
            "Should have variant_count field as i64"
        );
        assert!(
            code.code.contains("SELECT COUNT(*)"),
            "Should generate COUNT subquery in SQL"
        );
        assert!(
            code.code.contains("product_variant"),
            "Should reference product_variant table in COUNT"
        );
        assert!(
            code.code.contains("variant_count"),
            "Should alias the COUNT result"
        );
    }
}
