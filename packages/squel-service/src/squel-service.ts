// @generated by roam-codegen
// DO NOT EDIT - regenerate with `cargo xtask codegen --typescript`

import type { MethodHandler, MethodSchema, Caller } from "@bearcove/roam-core";
import * as pc from "@bearcove/roam-postcard";
import { encodeResultOk, encodeResultErr, encodeInvalidPayload, encodeWithSchema, decodeWithSchema, helloExchangeInitiator, defaultHello, CallBuilder } from "@bearcove/roam-core";
import { connectWs } from "@bearcove/roam-ws";
import { RpcError } from "@bearcove/roam-core";

export const METHOD_ID = {
  schema: 0xf0694b64f25d44ffn,
  list: 0xf4944ea4d9e891c1n,
  get: 0x1b8a7ad7106234c6n,
  create: 0x8ab9f5d104a6718en,
  update: 0xce45c093f47db097n,
  delete: 0x9e3f878d91c08d03n,
} as const;

// Named type definitions
export interface ColumnInfo {
  name: string;
  sql_type: string;
  rust_type: string | null;
  nullable: boolean;
  default: string | null;
  primary_key: boolean;
  unique: boolean;
  auto_generated: boolean;
  long: boolean;
  label: boolean;
  enum_variants: string[];
  doc: string | null;
  lang: string | null;
  icon: string | null;
  subtype: string | null;
}

export interface ForeignKeyInfo {
  columns: string[];
  references_table: string;
  references_columns: string[];
}

export interface IndexColumnInfo {
  name: string;
  order: string;
  nulls: string;
}

export interface IndexInfo {
  name: string;
  columns: IndexColumnInfo[];
  unique: boolean;
  where_clause: string | null;
}

export interface TableInfo {
  name: string;
  columns: ColumnInfo[];
  foreign_keys: ForeignKeyInfo[];
  indices: IndexInfo[];
  source_file: string | null;
  source_line: number | null;
  doc: string | null;
  icon: string | null;
}

export interface SchemaInfo {
  tables: TableInfo[];
}

export type FilterOp =
  | { tag: 'Eq' }
  | { tag: 'Ne' }
  | { tag: 'Lt' }
  | { tag: 'Lte' }
  | { tag: 'Gt' }
  | { tag: 'Gte' }
  | { tag: 'Like' }
  | { tag: 'ILike' }
  | { tag: 'IsNull' }
  | { tag: 'IsNotNull' }
  | { tag: 'In' }
  | { tag: 'JsonGet' }
  | { tag: 'JsonGetText' }
  | { tag: 'Contains' }
  | { tag: 'KeyExists' };

export type Value =
  | { tag: 'Null' }
  | { tag: 'Bool'; value: boolean }
  | { tag: 'I16'; value: number }
  | { tag: 'I32'; value: number }
  | { tag: 'I64'; value: bigint }
  | { tag: 'F32'; value: number }
  | { tag: 'F64'; value: number }
  | { tag: 'String'; value: string }
  | { tag: 'Bytes'; value: Uint8Array };

export interface Filter {
  field: string;
  op: FilterOp;
  value: Value;
  values: Value[];
}

export type SortDir =
  | { tag: 'Asc' }
  | { tag: 'Desc' };

export interface Sort {
  field: string;
  dir: SortDir;
}

export interface ListRequest {
  table: string;
  filters: Filter[];
  sort: Sort[];
  limit: number | null;
  offset: number | null;
  select: string[];
}

export interface RowField {
  name: string;
  value: Value;
}

export interface Row {
  fields: RowField[];
}

export interface ListResponse {
  rows: Row[];
  total: bigint | null;
}

export interface SqlError {
  message: string;
  sql: string | null;
  position: number | null;
  hint: string | null;
  detail: string | null;
  caller: string | null;
}

export type DibsError =
  | { tag: 'ConnectionFailed'; value: string }
  | { tag: 'MigrationFailed'; value: SqlError }
  | { tag: 'InvalidRequest'; value: string }
  | { tag: 'UnknownTable'; value: string }
  | { tag: 'UnknownColumn'; value: string }
  | { tag: 'QueryError'; value: string };

export interface GetRequest {
  table: string;
  pk: Value;
}

export interface CreateRequest {
  table: string;
  data: Row;
}

export interface UpdateRequest {
  table: string;
  pk: Value;
  data: Row;
}

export interface DeleteRequest {
  table: string;
  pk: Value;
}

// Request/Response type aliases
export type SchemaRequest = [];
export type SchemaResponse = SchemaInfo;


export type GetResponse = { ok: true; value: Row | null } | { ok: false; error: DibsError };

export type CreateResponse = { ok: true; value: Row } | { ok: false; error: DibsError };

export type UpdateResponse = { ok: true; value: Row } | { ok: false; error: DibsError };

export type DeleteResponse = { ok: true; value: bigint } | { ok: false; error: DibsError };

// Caller interface for SquelService
export interface SquelServiceCaller {
  /** Get the schema for all registered tables. */
  schema(): CallBuilder<SchemaInfo>;
  /** List rows from a table with filtering, sorting, and pagination. */
  list(request: ListRequest): CallBuilder<{ ok: true; value: ListResponse } | { ok: false; error: DibsError }>;
  /** Get a single row by primary key. */
  get(request: GetRequest): CallBuilder<{ ok: true; value: Row | null } | { ok: false; error: DibsError }>;
  /** Create a new row. */
  create(request: CreateRequest): CallBuilder<{ ok: true; value: Row } | { ok: false; error: DibsError }>;
  /** Update an existing row. */
  update(request: UpdateRequest): CallBuilder<{ ok: true; value: Row } | { ok: false; error: DibsError }>;
  /** Delete a row. */
  delete(request: DeleteRequest): CallBuilder<{ ok: true; value: bigint } | { ok: false; error: DibsError }>;
}

// Client implementation for SquelService
export class SquelServiceClient implements SquelServiceCaller {
  private caller: Caller;

  constructor(caller: Caller) {
    this.caller = caller;
  }

  /** Get the schema for all registered tables. */
  schema(): CallBuilder<SchemaInfo> {
    const schema = squelService_schemas.schema;
    return new CallBuilder(async (metadata) => {
      const response = await this.caller.call({
        methodId: 0xf0694b64f25d44ffn,
        method: "SquelService.schema",
        args: {},
        schema,
        metadata,
      });
      return response as SchemaInfo;
    });
  }

  /** List rows from a table with filtering, sorting, and pagination. */
  list(request: ListRequest): CallBuilder<{ ok: true; value: ListResponse } | { ok: false; error: DibsError }> {
    const schema = squelService_schemas.list;
    return new CallBuilder(async (metadata) => {
      try {
        const response = await this.caller.call({
          methodId: 0xf4944ea4d9e891c1n,
          method: "SquelService.list",
          args: { request },
          schema,
          metadata,
        });
        return { ok: true, value: response } as { ok: true; value: ListResponse } | { ok: false; error: DibsError };
      } catch (e) {
        if (e instanceof RpcError && e.isUserError() && e.payload && schema.error) {
          const error = decodeWithSchema(e.payload, 0, schema.error).value;
          return { ok: false, error } as { ok: true; value: ListResponse } | { ok: false; error: DibsError };
        }
        throw e;
      }
    });
  }

  /** Get a single row by primary key. */
  get(request: GetRequest): CallBuilder<{ ok: true; value: Row | null } | { ok: false; error: DibsError }> {
    const schema = squelService_schemas.get;
    return new CallBuilder(async (metadata) => {
      try {
        const response = await this.caller.call({
          methodId: 0x1b8a7ad7106234c6n,
          method: "SquelService.get",
          args: { request },
          schema,
          metadata,
        });
        return { ok: true, value: response } as { ok: true; value: Row | null } | { ok: false; error: DibsError };
      } catch (e) {
        if (e instanceof RpcError && e.isUserError() && e.payload && schema.error) {
          const error = decodeWithSchema(e.payload, 0, schema.error).value;
          return { ok: false, error } as { ok: true; value: Row | null } | { ok: false; error: DibsError };
        }
        throw e;
      }
    });
  }

  /** Create a new row. */
  create(request: CreateRequest): CallBuilder<{ ok: true; value: Row } | { ok: false; error: DibsError }> {
    const schema = squelService_schemas.create;
    return new CallBuilder(async (metadata) => {
      try {
        const response = await this.caller.call({
          methodId: 0x8ab9f5d104a6718en,
          method: "SquelService.create",
          args: { request },
          schema,
          metadata,
        });
        return { ok: true, value: response } as { ok: true; value: Row } | { ok: false; error: DibsError };
      } catch (e) {
        if (e instanceof RpcError && e.isUserError() && e.payload && schema.error) {
          const error = decodeWithSchema(e.payload, 0, schema.error).value;
          return { ok: false, error } as { ok: true; value: Row } | { ok: false; error: DibsError };
        }
        throw e;
      }
    });
  }

  /** Update an existing row. */
  update(request: UpdateRequest): CallBuilder<{ ok: true; value: Row } | { ok: false; error: DibsError }> {
    const schema = squelService_schemas.update;
    return new CallBuilder(async (metadata) => {
      try {
        const response = await this.caller.call({
          methodId: 0xce45c093f47db097n,
          method: "SquelService.update",
          args: { request },
          schema,
          metadata,
        });
        return { ok: true, value: response } as { ok: true; value: Row } | { ok: false; error: DibsError };
      } catch (e) {
        if (e instanceof RpcError && e.isUserError() && e.payload && schema.error) {
          const error = decodeWithSchema(e.payload, 0, schema.error).value;
          return { ok: false, error } as { ok: true; value: Row } | { ok: false; error: DibsError };
        }
        throw e;
      }
    });
  }

  /** Delete a row. */
  delete(request: DeleteRequest): CallBuilder<{ ok: true; value: bigint } | { ok: false; error: DibsError }> {
    const schema = squelService_schemas.delete;
    return new CallBuilder(async (metadata) => {
      try {
        const response = await this.caller.call({
          methodId: 0x9e3f878d91c08d03n,
          method: "SquelService.delete",
          args: { request },
          schema,
          metadata,
        });
        return { ok: true, value: response } as { ok: true; value: bigint } | { ok: false; error: DibsError };
      } catch (e) {
        if (e instanceof RpcError && e.isUserError() && e.payload && schema.error) {
          const error = decodeWithSchema(e.payload, 0, schema.error).value;
          return { ok: false, error } as { ok: true; value: bigint } | { ok: false; error: DibsError };
        }
        throw e;
      }
    });
  }

}

/**
 * Connect to a SquelService server over WebSocket.
 * @param url - WebSocket URL (e.g., "ws://localhost:9000")
 * @returns A connected SquelServiceClient instance
 */
export async function connectSquelService(url: string): Promise<SquelServiceClient> {
  const transport = await connectWs(url);
  const connection = await helloExchangeInitiator(transport, defaultHello());
  return new SquelServiceClient(connection.asCaller());
}

// Handler interface for SquelService
export interface SquelServiceHandler {
  schema(): Promise<SchemaInfo> | SchemaInfo;
  list(request: ListRequest): Promise<{ ok: true; value: ListResponse } | { ok: false; error: DibsError }> | { ok: true; value: ListResponse } | { ok: false; error: DibsError };
  get(request: GetRequest): Promise<{ ok: true; value: Row | null } | { ok: false; error: DibsError }> | { ok: true; value: Row | null } | { ok: false; error: DibsError };
  create(request: CreateRequest): Promise<{ ok: true; value: Row } | { ok: false; error: DibsError }> | { ok: true; value: Row } | { ok: false; error: DibsError };
  update(request: UpdateRequest): Promise<{ ok: true; value: Row } | { ok: false; error: DibsError }> | { ok: true; value: Row } | { ok: false; error: DibsError };
  delete(request: DeleteRequest): Promise<{ ok: true; value: bigint } | { ok: false; error: DibsError }> | { ok: true; value: bigint } | { ok: false; error: DibsError };
}

// Method handlers for SquelService
export const squelService_methodHandlers = new Map<bigint, MethodHandler<SquelServiceHandler>>([
  [0xf0694b64f25d44ffn, async (handler, payload) => {
    // Decode arguments - errors here are InvalidPayload
    let args;
    try {
      const buf = payload;
      let offset = 0;
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      args = {};
    } catch (_decodeError) {
      return encodeResultErr(encodeInvalidPayload());
    }

    // Call handler - errors propagate for infallible methods
    const result = await handler.schema();
    return encodeResultOk(pc.concat(pc.encodeVec(result.tables, (item: TableInfo) => pc.concat(pc.encodeString(item.name), pc.encodeVec(item.columns, (item: ColumnInfo) => pc.concat(pc.encodeString(item.name), pc.encodeString(item.sql_type), pc.encodeOption(item.rust_type, (v: string) => pc.encodeString(v)), pc.encodeBool(item.nullable), pc.encodeOption(item.default, (v: string) => pc.encodeString(v)), pc.encodeBool(item.primary_key), pc.encodeBool(item.unique), pc.encodeBool(item.auto_generated), pc.encodeBool(item.long), pc.encodeBool(item.label), pc.encodeVec(item.enum_variants, (item: string) => pc.encodeString(item)), pc.encodeOption(item.doc, (v: string) => pc.encodeString(v)), pc.encodeOption(item.lang, (v: string) => pc.encodeString(v)), pc.encodeOption(item.icon, (v: string) => pc.encodeString(v)), pc.encodeOption(item.subtype, (v: string) => pc.encodeString(v)))), pc.encodeVec(item.foreign_keys, (item: ForeignKeyInfo) => pc.concat(pc.encodeVec(item.columns, (item: string) => pc.encodeString(item)), pc.encodeString(item.references_table), pc.encodeVec(item.references_columns, (item: string) => pc.encodeString(item)))), pc.encodeVec(item.indices, (item: IndexInfo) => pc.concat(pc.encodeString(item.name), pc.encodeVec(item.columns, (item: IndexColumnInfo) => pc.concat(pc.encodeString(item.name), pc.encodeString(item.order), pc.encodeString(item.nulls))), pc.encodeBool(item.unique), pc.encodeOption(item.where_clause, (v: string) => pc.encodeString(v)))), pc.encodeOption(item.source_file, (v: string) => pc.encodeString(v)), pc.encodeOption(item.source_line, (v: number) => pc.encodeU32(v)), pc.encodeOption(item.doc, (v: string) => pc.encodeString(v)), pc.encodeOption(item.icon, (v: string) => pc.encodeString(v))))));
  }],
  [0xf4944ea4d9e891c1n, async (handler, payload) => {
    // Decode arguments - errors here are InvalidPayload
    let args;
    try {
      const buf = payload;
      let offset = 0;
      const _request_f0_r = pc.decodeString(buf, offset); const request_f0 = _request_f0_r.value; offset = _request_f0_r.next;
const _request_f1_r = pc.decodeVec(buf, offset, (buf: Uint8Array, off: number) => { let o = off;
  const _f0_r = pc.decodeString(buf, o); const f0 = _f0_r.value; o = _f0_r.next;
  const _f1_disc = pc.decodeEnumVariant(buf, o); o = _f1_disc.next;
let f1: FilterOp;
switch (_f1_disc.value) {
  case 0: {
    f1 = { tag: 'Eq' };
    break;
  }
  case 1: {
    f1 = { tag: 'Ne' };
    break;
  }
  case 2: {
    f1 = { tag: 'Lt' };
    break;
  }
  case 3: {
    f1 = { tag: 'Lte' };
    break;
  }
  case 4: {
    f1 = { tag: 'Gt' };
    break;
  }
  case 5: {
    f1 = { tag: 'Gte' };
    break;
  }
  case 6: {
    f1 = { tag: 'Like' };
    break;
  }
  case 7: {
    f1 = { tag: 'ILike' };
    break;
  }
  case 8: {
    f1 = { tag: 'IsNull' };
    break;
  }
  case 9: {
    f1 = { tag: 'IsNotNull' };
    break;
  }
  case 10: {
    f1 = { tag: 'In' };
    break;
  }
  case 11: {
    f1 = { tag: 'JsonGet' };
    break;
  }
  case 12: {
    f1 = { tag: 'JsonGetText' };
    break;
  }
  case 13: {
    f1 = { tag: 'Contains' };
    break;
  }
  case 14: {
    f1 = { tag: 'KeyExists' };
    break;
  }
  default: throw new Error(`unknown enum variant ${_f1_disc.value}`);
}
  const _f2_disc = pc.decodeEnumVariant(buf, o); o = _f2_disc.next;
let f2: Value;
switch (_f2_disc.value) {
  case 0: {
    f2 = { tag: 'Null' };
    break;
  }
  case 1: {
    const _f2_inner_r = pc.decodeBool(buf, o); const f2_inner = _f2_inner_r.value; o = _f2_inner_r.next;
    f2 = { tag: 'Bool', value: f2_inner };
    break;
  }
  case 2: {
    const _f2_inner_r = pc.decodeI16(buf, o); const f2_inner = _f2_inner_r.value; o = _f2_inner_r.next;
    f2 = { tag: 'I16', value: f2_inner };
    break;
  }
  case 3: {
    const _f2_inner_r = pc.decodeI32(buf, o); const f2_inner = _f2_inner_r.value; o = _f2_inner_r.next;
    f2 = { tag: 'I32', value: f2_inner };
    break;
  }
  case 4: {
    const _f2_inner_r = pc.decodeI64(buf, o); const f2_inner = _f2_inner_r.value; o = _f2_inner_r.next;
    f2 = { tag: 'I64', value: f2_inner };
    break;
  }
  case 5: {
    const _f2_inner_r = pc.decodeF32(buf, o); const f2_inner = _f2_inner_r.value; o = _f2_inner_r.next;
    f2 = { tag: 'F32', value: f2_inner };
    break;
  }
  case 6: {
    const _f2_inner_r = pc.decodeF64(buf, o); const f2_inner = _f2_inner_r.value; o = _f2_inner_r.next;
    f2 = { tag: 'F64', value: f2_inner };
    break;
  }
  case 7: {
    const _f2_inner_r = pc.decodeString(buf, o); const f2_inner = _f2_inner_r.value; o = _f2_inner_r.next;
    f2 = { tag: 'String', value: f2_inner };
    break;
  }
  case 8: {
    const _f2_inner_r = pc.decodeBytes(buf, o); const f2_inner = _f2_inner_r.value; o = _f2_inner_r.next;
    f2 = { tag: 'Bytes', value: f2_inner };
    break;
  }
  default: throw new Error(`unknown enum variant ${_f2_disc.value}`);
}
  const _f3_r = pc.decodeVec(buf, o, (buf: Uint8Array, off: number): pc.DecodeResult<any> => { let o = off;
  const disc = pc.decodeEnumVariant(buf, o); o = disc.next;
  switch (disc.value) {
    case 0: return { value: { tag: 'Null' }, next: o };
    case 1: {
      const _val_r = pc.decodeBool(buf, o); const val = _val_r.value; o = _val_r.next;
      return { value: { tag: 'Bool', value: val }, next: o };
    }
    case 2: {
      const _val_r = pc.decodeI16(buf, o); const val = _val_r.value; o = _val_r.next;
      return { value: { tag: 'I16', value: val }, next: o };
    }
    case 3: {
      const _val_r = pc.decodeI32(buf, o); const val = _val_r.value; o = _val_r.next;
      return { value: { tag: 'I32', value: val }, next: o };
    }
    case 4: {
      const _val_r = pc.decodeI64(buf, o); const val = _val_r.value; o = _val_r.next;
      return { value: { tag: 'I64', value: val }, next: o };
    }
    case 5: {
      const _val_r = pc.decodeF32(buf, o); const val = _val_r.value; o = _val_r.next;
      return { value: { tag: 'F32', value: val }, next: o };
    }
    case 6: {
      const _val_r = pc.decodeF64(buf, o); const val = _val_r.value; o = _val_r.next;
      return { value: { tag: 'F64', value: val }, next: o };
    }
    case 7: {
      const _val_r = pc.decodeString(buf, o); const val = _val_r.value; o = _val_r.next;
      return { value: { tag: 'String', value: val }, next: o };
    }
    case 8: {
      const _val_r = pc.decodeBytes(buf, o); const val = _val_r.value; o = _val_r.next;
      return { value: { tag: 'Bytes', value: val }, next: o };
    }
    default: throw new Error(`unknown enum variant: ${disc.value}`);
  }
}); const f3 = _f3_r.value; o = _f3_r.next;
  return { value: { field: f0, op: f1, value: f2, values: f3 }, next: o };
}); const request_f1 = _request_f1_r.value; offset = _request_f1_r.next;
const _request_f2_r = pc.decodeVec(buf, offset, (buf: Uint8Array, off: number) => { let o = off;
  const _f0_r = pc.decodeString(buf, o); const f0 = _f0_r.value; o = _f0_r.next;
  const _f1_disc = pc.decodeEnumVariant(buf, o); o = _f1_disc.next;
let f1: SortDir;
switch (_f1_disc.value) {
  case 0: {
    f1 = { tag: 'Asc' };
    break;
  }
  case 1: {
    f1 = { tag: 'Desc' };
    break;
  }
  default: throw new Error(`unknown enum variant ${_f1_disc.value}`);
}
  return { value: { field: f0, dir: f1 }, next: o };
}); const request_f2 = _request_f2_r.value; offset = _request_f2_r.next;
const _request_f3_r = pc.decodeOption(buf, offset, (buf, off) => pc.decodeU32(buf, off)); const request_f3 = _request_f3_r.value; offset = _request_f3_r.next;
const _request_f4_r = pc.decodeOption(buf, offset, (buf, off) => pc.decodeU32(buf, off)); const request_f4 = _request_f4_r.value; offset = _request_f4_r.next;
const _request_f5_r = pc.decodeVec(buf, offset, (buf, off) => pc.decodeString(buf, off)); const request_f5 = _request_f5_r.value; offset = _request_f5_r.next;
const request = { table: request_f0, filters: request_f1, sort: request_f2, limit: request_f3, offset: request_f4, select: request_f5 };
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      args = { request };
    } catch (_decodeError) {
      return encodeResultErr(encodeInvalidPayload());
    }

    // Call handler - errors propagate for infallible methods
    const result = await handler.list(args.request);
    if (result.ok) {
      return pc.concat(pc.encodeU8(0), pc.concat(pc.encodeVec(result.value.rows, (item: Row) => pc.concat(pc.encodeVec(item.fields, (item: RowField) => pc.concat(pc.encodeString(item.name), (() => { switch (item.value.tag) {
      case 'Null': return pc.encodeEnumVariant(0);
      case 'Bool': return pc.concat(pc.encodeEnumVariant(1), pc.encodeBool(item.value.value));
      case 'I16': return pc.concat(pc.encodeEnumVariant(2), pc.encodeI16(item.value.value));
      case 'I32': return pc.concat(pc.encodeEnumVariant(3), pc.encodeI32(item.value.value));
      case 'I64': return pc.concat(pc.encodeEnumVariant(4), pc.encodeI64(item.value.value));
      case 'F32': return pc.concat(pc.encodeEnumVariant(5), pc.encodeF32(item.value.value));
      case 'F64': return pc.concat(pc.encodeEnumVariant(6), pc.encodeF64(item.value.value));
      case 'String': return pc.concat(pc.encodeEnumVariant(7), pc.encodeString(item.value.value));
      case 'Bytes': return pc.concat(pc.encodeEnumVariant(8), pc.encodeBytes(item.value.value));
      default: throw new Error('unknown enum variant'); } })())))), pc.encodeOption(result.value.total, (v: bigint) => pc.encodeU64(v))));
    } else {
      return pc.concat(pc.encodeU8(1), pc.encodeU8(0), (() => { switch (result.error.tag) {
      case 'ConnectionFailed': return pc.concat(pc.encodeEnumVariant(0), pc.encodeString(result.error.value));
      case 'MigrationFailed': return pc.concat(pc.encodeEnumVariant(1), pc.concat(pc.encodeString(result.error.value.message), pc.encodeOption(result.error.value.sql, (v: string) => pc.encodeString(v)), pc.encodeOption(result.error.value.position, (v: number) => pc.encodeU32(v)), pc.encodeOption(result.error.value.hint, (v: string) => pc.encodeString(v)), pc.encodeOption(result.error.value.detail, (v: string) => pc.encodeString(v)), pc.encodeOption(result.error.value.caller, (v: string) => pc.encodeString(v))));
      case 'InvalidRequest': return pc.concat(pc.encodeEnumVariant(2), pc.encodeString(result.error.value));
      case 'UnknownTable': return pc.concat(pc.encodeEnumVariant(3), pc.encodeString(result.error.value));
      case 'UnknownColumn': return pc.concat(pc.encodeEnumVariant(4), pc.encodeString(result.error.value));
      case 'QueryError': return pc.concat(pc.encodeEnumVariant(5), pc.encodeString(result.error.value));
      default: throw new Error('unknown enum variant'); } })());
    }
  }],
  [0x1b8a7ad7106234c6n, async (handler, payload) => {
    // Decode arguments - errors here are InvalidPayload
    let args;
    try {
      const buf = payload;
      let offset = 0;
      const _request_f0_r = pc.decodeString(buf, offset); const request_f0 = _request_f0_r.value; offset = _request_f0_r.next;
const _request_f1_disc = pc.decodeEnumVariant(buf, offset); offset = _request_f1_disc.next;
let request_f1: Value;
switch (_request_f1_disc.value) {
  case 0: {
    request_f1 = { tag: 'Null' };
    break;
  }
  case 1: {
    const _request_f1_inner_r = pc.decodeBool(buf, offset); const request_f1_inner = _request_f1_inner_r.value; offset = _request_f1_inner_r.next;
    request_f1 = { tag: 'Bool', value: request_f1_inner };
    break;
  }
  case 2: {
    const _request_f1_inner_r = pc.decodeI16(buf, offset); const request_f1_inner = _request_f1_inner_r.value; offset = _request_f1_inner_r.next;
    request_f1 = { tag: 'I16', value: request_f1_inner };
    break;
  }
  case 3: {
    const _request_f1_inner_r = pc.decodeI32(buf, offset); const request_f1_inner = _request_f1_inner_r.value; offset = _request_f1_inner_r.next;
    request_f1 = { tag: 'I32', value: request_f1_inner };
    break;
  }
  case 4: {
    const _request_f1_inner_r = pc.decodeI64(buf, offset); const request_f1_inner = _request_f1_inner_r.value; offset = _request_f1_inner_r.next;
    request_f1 = { tag: 'I64', value: request_f1_inner };
    break;
  }
  case 5: {
    const _request_f1_inner_r = pc.decodeF32(buf, offset); const request_f1_inner = _request_f1_inner_r.value; offset = _request_f1_inner_r.next;
    request_f1 = { tag: 'F32', value: request_f1_inner };
    break;
  }
  case 6: {
    const _request_f1_inner_r = pc.decodeF64(buf, offset); const request_f1_inner = _request_f1_inner_r.value; offset = _request_f1_inner_r.next;
    request_f1 = { tag: 'F64', value: request_f1_inner };
    break;
  }
  case 7: {
    const _request_f1_inner_r = pc.decodeString(buf, offset); const request_f1_inner = _request_f1_inner_r.value; offset = _request_f1_inner_r.next;
    request_f1 = { tag: 'String', value: request_f1_inner };
    break;
  }
  case 8: {
    const _request_f1_inner_r = pc.decodeBytes(buf, offset); const request_f1_inner = _request_f1_inner_r.value; offset = _request_f1_inner_r.next;
    request_f1 = { tag: 'Bytes', value: request_f1_inner };
    break;
  }
  default: throw new Error(`unknown enum variant ${_request_f1_disc.value}`);
}
const request = { table: request_f0, pk: request_f1 };
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      args = { request };
    } catch (_decodeError) {
      return encodeResultErr(encodeInvalidPayload());
    }

    // Call handler - errors propagate for infallible methods
    const result = await handler.get(args.request);
    if (result.ok) {
      return pc.concat(pc.encodeU8(0), pc.encodeOption(result.value, (v: Row) => pc.concat(pc.encodeVec(v.fields, (item: RowField) => pc.concat(pc.encodeString(item.name), (() => { switch (item.value.tag) {
      case 'Null': return pc.encodeEnumVariant(0);
      case 'Bool': return pc.concat(pc.encodeEnumVariant(1), pc.encodeBool(item.value.value));
      case 'I16': return pc.concat(pc.encodeEnumVariant(2), pc.encodeI16(item.value.value));
      case 'I32': return pc.concat(pc.encodeEnumVariant(3), pc.encodeI32(item.value.value));
      case 'I64': return pc.concat(pc.encodeEnumVariant(4), pc.encodeI64(item.value.value));
      case 'F32': return pc.concat(pc.encodeEnumVariant(5), pc.encodeF32(item.value.value));
      case 'F64': return pc.concat(pc.encodeEnumVariant(6), pc.encodeF64(item.value.value));
      case 'String': return pc.concat(pc.encodeEnumVariant(7), pc.encodeString(item.value.value));
      case 'Bytes': return pc.concat(pc.encodeEnumVariant(8), pc.encodeBytes(item.value.value));
      default: throw new Error('unknown enum variant'); } })())))));
    } else {
      return pc.concat(pc.encodeU8(1), pc.encodeU8(0), (() => { switch (result.error.tag) {
      case 'ConnectionFailed': return pc.concat(pc.encodeEnumVariant(0), pc.encodeString(result.error.value));
      case 'MigrationFailed': return pc.concat(pc.encodeEnumVariant(1), pc.concat(pc.encodeString(result.error.value.message), pc.encodeOption(result.error.value.sql, (v: string) => pc.encodeString(v)), pc.encodeOption(result.error.value.position, (v: number) => pc.encodeU32(v)), pc.encodeOption(result.error.value.hint, (v: string) => pc.encodeString(v)), pc.encodeOption(result.error.value.detail, (v: string) => pc.encodeString(v)), pc.encodeOption(result.error.value.caller, (v: string) => pc.encodeString(v))));
      case 'InvalidRequest': return pc.concat(pc.encodeEnumVariant(2), pc.encodeString(result.error.value));
      case 'UnknownTable': return pc.concat(pc.encodeEnumVariant(3), pc.encodeString(result.error.value));
      case 'UnknownColumn': return pc.concat(pc.encodeEnumVariant(4), pc.encodeString(result.error.value));
      case 'QueryError': return pc.concat(pc.encodeEnumVariant(5), pc.encodeString(result.error.value));
      default: throw new Error('unknown enum variant'); } })());
    }
  }],
  [0x8ab9f5d104a6718en, async (handler, payload) => {
    // Decode arguments - errors here are InvalidPayload
    let args;
    try {
      const buf = payload;
      let offset = 0;
      const _request_f0_r = pc.decodeString(buf, offset); const request_f0 = _request_f0_r.value; offset = _request_f0_r.next;
const _request_f1_f0_r = pc.decodeVec(buf, offset, (buf: Uint8Array, off: number) => { let o = off;
  const _f0_r = pc.decodeString(buf, o); const f0 = _f0_r.value; o = _f0_r.next;
  const _f1_disc = pc.decodeEnumVariant(buf, o); o = _f1_disc.next;
let f1: Value;
switch (_f1_disc.value) {
  case 0: {
    f1 = { tag: 'Null' };
    break;
  }
  case 1: {
    const _f1_inner_r = pc.decodeBool(buf, o); const f1_inner = _f1_inner_r.value; o = _f1_inner_r.next;
    f1 = { tag: 'Bool', value: f1_inner };
    break;
  }
  case 2: {
    const _f1_inner_r = pc.decodeI16(buf, o); const f1_inner = _f1_inner_r.value; o = _f1_inner_r.next;
    f1 = { tag: 'I16', value: f1_inner };
    break;
  }
  case 3: {
    const _f1_inner_r = pc.decodeI32(buf, o); const f1_inner = _f1_inner_r.value; o = _f1_inner_r.next;
    f1 = { tag: 'I32', value: f1_inner };
    break;
  }
  case 4: {
    const _f1_inner_r = pc.decodeI64(buf, o); const f1_inner = _f1_inner_r.value; o = _f1_inner_r.next;
    f1 = { tag: 'I64', value: f1_inner };
    break;
  }
  case 5: {
    const _f1_inner_r = pc.decodeF32(buf, o); const f1_inner = _f1_inner_r.value; o = _f1_inner_r.next;
    f1 = { tag: 'F32', value: f1_inner };
    break;
  }
  case 6: {
    const _f1_inner_r = pc.decodeF64(buf, o); const f1_inner = _f1_inner_r.value; o = _f1_inner_r.next;
    f1 = { tag: 'F64', value: f1_inner };
    break;
  }
  case 7: {
    const _f1_inner_r = pc.decodeString(buf, o); const f1_inner = _f1_inner_r.value; o = _f1_inner_r.next;
    f1 = { tag: 'String', value: f1_inner };
    break;
  }
  case 8: {
    const _f1_inner_r = pc.decodeBytes(buf, o); const f1_inner = _f1_inner_r.value; o = _f1_inner_r.next;
    f1 = { tag: 'Bytes', value: f1_inner };
    break;
  }
  default: throw new Error(`unknown enum variant ${_f1_disc.value}`);
}
  return { value: { name: f0, value: f1 }, next: o };
}); const request_f1_f0 = _request_f1_f0_r.value; offset = _request_f1_f0_r.next;
const request_f1 = { fields: request_f1_f0 };
const request = { table: request_f0, data: request_f1 };
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      args = { request };
    } catch (_decodeError) {
      return encodeResultErr(encodeInvalidPayload());
    }

    // Call handler - errors propagate for infallible methods
    const result = await handler.create(args.request);
    if (result.ok) {
      return pc.concat(pc.encodeU8(0), pc.concat(pc.encodeVec(result.value.fields, (item: RowField) => pc.concat(pc.encodeString(item.name), (() => { switch (item.value.tag) {
      case 'Null': return pc.encodeEnumVariant(0);
      case 'Bool': return pc.concat(pc.encodeEnumVariant(1), pc.encodeBool(item.value.value));
      case 'I16': return pc.concat(pc.encodeEnumVariant(2), pc.encodeI16(item.value.value));
      case 'I32': return pc.concat(pc.encodeEnumVariant(3), pc.encodeI32(item.value.value));
      case 'I64': return pc.concat(pc.encodeEnumVariant(4), pc.encodeI64(item.value.value));
      case 'F32': return pc.concat(pc.encodeEnumVariant(5), pc.encodeF32(item.value.value));
      case 'F64': return pc.concat(pc.encodeEnumVariant(6), pc.encodeF64(item.value.value));
      case 'String': return pc.concat(pc.encodeEnumVariant(7), pc.encodeString(item.value.value));
      case 'Bytes': return pc.concat(pc.encodeEnumVariant(8), pc.encodeBytes(item.value.value));
      default: throw new Error('unknown enum variant'); } })()))));
    } else {
      return pc.concat(pc.encodeU8(1), pc.encodeU8(0), (() => { switch (result.error.tag) {
      case 'ConnectionFailed': return pc.concat(pc.encodeEnumVariant(0), pc.encodeString(result.error.value));
      case 'MigrationFailed': return pc.concat(pc.encodeEnumVariant(1), pc.concat(pc.encodeString(result.error.value.message), pc.encodeOption(result.error.value.sql, (v: string) => pc.encodeString(v)), pc.encodeOption(result.error.value.position, (v: number) => pc.encodeU32(v)), pc.encodeOption(result.error.value.hint, (v: string) => pc.encodeString(v)), pc.encodeOption(result.error.value.detail, (v: string) => pc.encodeString(v)), pc.encodeOption(result.error.value.caller, (v: string) => pc.encodeString(v))));
      case 'InvalidRequest': return pc.concat(pc.encodeEnumVariant(2), pc.encodeString(result.error.value));
      case 'UnknownTable': return pc.concat(pc.encodeEnumVariant(3), pc.encodeString(result.error.value));
      case 'UnknownColumn': return pc.concat(pc.encodeEnumVariant(4), pc.encodeString(result.error.value));
      case 'QueryError': return pc.concat(pc.encodeEnumVariant(5), pc.encodeString(result.error.value));
      default: throw new Error('unknown enum variant'); } })());
    }
  }],
  [0xce45c093f47db097n, async (handler, payload) => {
    // Decode arguments - errors here are InvalidPayload
    let args;
    try {
      const buf = payload;
      let offset = 0;
      const _request_f0_r = pc.decodeString(buf, offset); const request_f0 = _request_f0_r.value; offset = _request_f0_r.next;
const _request_f1_disc = pc.decodeEnumVariant(buf, offset); offset = _request_f1_disc.next;
let request_f1: Value;
switch (_request_f1_disc.value) {
  case 0: {
    request_f1 = { tag: 'Null' };
    break;
  }
  case 1: {
    const _request_f1_inner_r = pc.decodeBool(buf, offset); const request_f1_inner = _request_f1_inner_r.value; offset = _request_f1_inner_r.next;
    request_f1 = { tag: 'Bool', value: request_f1_inner };
    break;
  }
  case 2: {
    const _request_f1_inner_r = pc.decodeI16(buf, offset); const request_f1_inner = _request_f1_inner_r.value; offset = _request_f1_inner_r.next;
    request_f1 = { tag: 'I16', value: request_f1_inner };
    break;
  }
  case 3: {
    const _request_f1_inner_r = pc.decodeI32(buf, offset); const request_f1_inner = _request_f1_inner_r.value; offset = _request_f1_inner_r.next;
    request_f1 = { tag: 'I32', value: request_f1_inner };
    break;
  }
  case 4: {
    const _request_f1_inner_r = pc.decodeI64(buf, offset); const request_f1_inner = _request_f1_inner_r.value; offset = _request_f1_inner_r.next;
    request_f1 = { tag: 'I64', value: request_f1_inner };
    break;
  }
  case 5: {
    const _request_f1_inner_r = pc.decodeF32(buf, offset); const request_f1_inner = _request_f1_inner_r.value; offset = _request_f1_inner_r.next;
    request_f1 = { tag: 'F32', value: request_f1_inner };
    break;
  }
  case 6: {
    const _request_f1_inner_r = pc.decodeF64(buf, offset); const request_f1_inner = _request_f1_inner_r.value; offset = _request_f1_inner_r.next;
    request_f1 = { tag: 'F64', value: request_f1_inner };
    break;
  }
  case 7: {
    const _request_f1_inner_r = pc.decodeString(buf, offset); const request_f1_inner = _request_f1_inner_r.value; offset = _request_f1_inner_r.next;
    request_f1 = { tag: 'String', value: request_f1_inner };
    break;
  }
  case 8: {
    const _request_f1_inner_r = pc.decodeBytes(buf, offset); const request_f1_inner = _request_f1_inner_r.value; offset = _request_f1_inner_r.next;
    request_f1 = { tag: 'Bytes', value: request_f1_inner };
    break;
  }
  default: throw new Error(`unknown enum variant ${_request_f1_disc.value}`);
}
const _request_f2_f0_r = pc.decodeVec(buf, offset, (buf: Uint8Array, off: number) => { let o = off;
  const _f0_r = pc.decodeString(buf, o); const f0 = _f0_r.value; o = _f0_r.next;
  const _f1_disc = pc.decodeEnumVariant(buf, o); o = _f1_disc.next;
let f1: Value;
switch (_f1_disc.value) {
  case 0: {
    f1 = { tag: 'Null' };
    break;
  }
  case 1: {
    const _f1_inner_r = pc.decodeBool(buf, o); const f1_inner = _f1_inner_r.value; o = _f1_inner_r.next;
    f1 = { tag: 'Bool', value: f1_inner };
    break;
  }
  case 2: {
    const _f1_inner_r = pc.decodeI16(buf, o); const f1_inner = _f1_inner_r.value; o = _f1_inner_r.next;
    f1 = { tag: 'I16', value: f1_inner };
    break;
  }
  case 3: {
    const _f1_inner_r = pc.decodeI32(buf, o); const f1_inner = _f1_inner_r.value; o = _f1_inner_r.next;
    f1 = { tag: 'I32', value: f1_inner };
    break;
  }
  case 4: {
    const _f1_inner_r = pc.decodeI64(buf, o); const f1_inner = _f1_inner_r.value; o = _f1_inner_r.next;
    f1 = { tag: 'I64', value: f1_inner };
    break;
  }
  case 5: {
    const _f1_inner_r = pc.decodeF32(buf, o); const f1_inner = _f1_inner_r.value; o = _f1_inner_r.next;
    f1 = { tag: 'F32', value: f1_inner };
    break;
  }
  case 6: {
    const _f1_inner_r = pc.decodeF64(buf, o); const f1_inner = _f1_inner_r.value; o = _f1_inner_r.next;
    f1 = { tag: 'F64', value: f1_inner };
    break;
  }
  case 7: {
    const _f1_inner_r = pc.decodeString(buf, o); const f1_inner = _f1_inner_r.value; o = _f1_inner_r.next;
    f1 = { tag: 'String', value: f1_inner };
    break;
  }
  case 8: {
    const _f1_inner_r = pc.decodeBytes(buf, o); const f1_inner = _f1_inner_r.value; o = _f1_inner_r.next;
    f1 = { tag: 'Bytes', value: f1_inner };
    break;
  }
  default: throw new Error(`unknown enum variant ${_f1_disc.value}`);
}
  return { value: { name: f0, value: f1 }, next: o };
}); const request_f2_f0 = _request_f2_f0_r.value; offset = _request_f2_f0_r.next;
const request_f2 = { fields: request_f2_f0 };
const request = { table: request_f0, pk: request_f1, data: request_f2 };
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      args = { request };
    } catch (_decodeError) {
      return encodeResultErr(encodeInvalidPayload());
    }

    // Call handler - errors propagate for infallible methods
    const result = await handler.update(args.request);
    if (result.ok) {
      return pc.concat(pc.encodeU8(0), pc.concat(pc.encodeVec(result.value.fields, (item: RowField) => pc.concat(pc.encodeString(item.name), (() => { switch (item.value.tag) {
      case 'Null': return pc.encodeEnumVariant(0);
      case 'Bool': return pc.concat(pc.encodeEnumVariant(1), pc.encodeBool(item.value.value));
      case 'I16': return pc.concat(pc.encodeEnumVariant(2), pc.encodeI16(item.value.value));
      case 'I32': return pc.concat(pc.encodeEnumVariant(3), pc.encodeI32(item.value.value));
      case 'I64': return pc.concat(pc.encodeEnumVariant(4), pc.encodeI64(item.value.value));
      case 'F32': return pc.concat(pc.encodeEnumVariant(5), pc.encodeF32(item.value.value));
      case 'F64': return pc.concat(pc.encodeEnumVariant(6), pc.encodeF64(item.value.value));
      case 'String': return pc.concat(pc.encodeEnumVariant(7), pc.encodeString(item.value.value));
      case 'Bytes': return pc.concat(pc.encodeEnumVariant(8), pc.encodeBytes(item.value.value));
      default: throw new Error('unknown enum variant'); } })()))));
    } else {
      return pc.concat(pc.encodeU8(1), pc.encodeU8(0), (() => { switch (result.error.tag) {
      case 'ConnectionFailed': return pc.concat(pc.encodeEnumVariant(0), pc.encodeString(result.error.value));
      case 'MigrationFailed': return pc.concat(pc.encodeEnumVariant(1), pc.concat(pc.encodeString(result.error.value.message), pc.encodeOption(result.error.value.sql, (v: string) => pc.encodeString(v)), pc.encodeOption(result.error.value.position, (v: number) => pc.encodeU32(v)), pc.encodeOption(result.error.value.hint, (v: string) => pc.encodeString(v)), pc.encodeOption(result.error.value.detail, (v: string) => pc.encodeString(v)), pc.encodeOption(result.error.value.caller, (v: string) => pc.encodeString(v))));
      case 'InvalidRequest': return pc.concat(pc.encodeEnumVariant(2), pc.encodeString(result.error.value));
      case 'UnknownTable': return pc.concat(pc.encodeEnumVariant(3), pc.encodeString(result.error.value));
      case 'UnknownColumn': return pc.concat(pc.encodeEnumVariant(4), pc.encodeString(result.error.value));
      case 'QueryError': return pc.concat(pc.encodeEnumVariant(5), pc.encodeString(result.error.value));
      default: throw new Error('unknown enum variant'); } })());
    }
  }],
  [0x9e3f878d91c08d03n, async (handler, payload) => {
    // Decode arguments - errors here are InvalidPayload
    let args;
    try {
      const buf = payload;
      let offset = 0;
      const _request_f0_r = pc.decodeString(buf, offset); const request_f0 = _request_f0_r.value; offset = _request_f0_r.next;
const _request_f1_disc = pc.decodeEnumVariant(buf, offset); offset = _request_f1_disc.next;
let request_f1: Value;
switch (_request_f1_disc.value) {
  case 0: {
    request_f1 = { tag: 'Null' };
    break;
  }
  case 1: {
    const _request_f1_inner_r = pc.decodeBool(buf, offset); const request_f1_inner = _request_f1_inner_r.value; offset = _request_f1_inner_r.next;
    request_f1 = { tag: 'Bool', value: request_f1_inner };
    break;
  }
  case 2: {
    const _request_f1_inner_r = pc.decodeI16(buf, offset); const request_f1_inner = _request_f1_inner_r.value; offset = _request_f1_inner_r.next;
    request_f1 = { tag: 'I16', value: request_f1_inner };
    break;
  }
  case 3: {
    const _request_f1_inner_r = pc.decodeI32(buf, offset); const request_f1_inner = _request_f1_inner_r.value; offset = _request_f1_inner_r.next;
    request_f1 = { tag: 'I32', value: request_f1_inner };
    break;
  }
  case 4: {
    const _request_f1_inner_r = pc.decodeI64(buf, offset); const request_f1_inner = _request_f1_inner_r.value; offset = _request_f1_inner_r.next;
    request_f1 = { tag: 'I64', value: request_f1_inner };
    break;
  }
  case 5: {
    const _request_f1_inner_r = pc.decodeF32(buf, offset); const request_f1_inner = _request_f1_inner_r.value; offset = _request_f1_inner_r.next;
    request_f1 = { tag: 'F32', value: request_f1_inner };
    break;
  }
  case 6: {
    const _request_f1_inner_r = pc.decodeF64(buf, offset); const request_f1_inner = _request_f1_inner_r.value; offset = _request_f1_inner_r.next;
    request_f1 = { tag: 'F64', value: request_f1_inner };
    break;
  }
  case 7: {
    const _request_f1_inner_r = pc.decodeString(buf, offset); const request_f1_inner = _request_f1_inner_r.value; offset = _request_f1_inner_r.next;
    request_f1 = { tag: 'String', value: request_f1_inner };
    break;
  }
  case 8: {
    const _request_f1_inner_r = pc.decodeBytes(buf, offset); const request_f1_inner = _request_f1_inner_r.value; offset = _request_f1_inner_r.next;
    request_f1 = { tag: 'Bytes', value: request_f1_inner };
    break;
  }
  default: throw new Error(`unknown enum variant ${_request_f1_disc.value}`);
}
const request = { table: request_f0, pk: request_f1 };
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      args = { request };
    } catch (_decodeError) {
      return encodeResultErr(encodeInvalidPayload());
    }

    // Call handler - errors propagate for infallible methods
    const result = await handler.delete(args.request);
    if (result.ok) {
      return pc.concat(pc.encodeU8(0), pc.encodeU64(result.value));
    } else {
      return pc.concat(pc.encodeU8(1), pc.encodeU8(0), (() => { switch (result.error.tag) {
      case 'ConnectionFailed': return pc.concat(pc.encodeEnumVariant(0), pc.encodeString(result.error.value));
      case 'MigrationFailed': return pc.concat(pc.encodeEnumVariant(1), pc.concat(pc.encodeString(result.error.value.message), pc.encodeOption(result.error.value.sql, (v: string) => pc.encodeString(v)), pc.encodeOption(result.error.value.position, (v: number) => pc.encodeU32(v)), pc.encodeOption(result.error.value.hint, (v: string) => pc.encodeString(v)), pc.encodeOption(result.error.value.detail, (v: string) => pc.encodeString(v)), pc.encodeOption(result.error.value.caller, (v: string) => pc.encodeString(v))));
      case 'InvalidRequest': return pc.concat(pc.encodeEnumVariant(2), pc.encodeString(result.error.value));
      case 'UnknownTable': return pc.concat(pc.encodeEnumVariant(3), pc.encodeString(result.error.value));
      case 'UnknownColumn': return pc.concat(pc.encodeEnumVariant(4), pc.encodeString(result.error.value));
      case 'QueryError': return pc.concat(pc.encodeEnumVariant(5), pc.encodeString(result.error.value));
      default: throw new Error('unknown enum variant'); } })());
    }
  }],
]);

// Method schemas for runtime encoding/decoding and channel binding
export const squelService_schemas: Record<string, MethodSchema> = {
  schema: { args: [], returns: { kind: 'struct', fields: { 'tables': { kind: 'vec', element: { kind: 'struct', fields: { 'name': { kind: 'string' }, 'columns': { kind: 'vec', element: { kind: 'struct', fields: { 'name': { kind: 'string' }, 'sql_type': { kind: 'string' }, 'rust_type': { kind: 'option', inner: { kind: 'string' } }, 'nullable': { kind: 'bool' }, 'default': { kind: 'option', inner: { kind: 'string' } }, 'primary_key': { kind: 'bool' }, 'unique': { kind: 'bool' }, 'auto_generated': { kind: 'bool' }, 'long': { kind: 'bool' }, 'label': { kind: 'bool' }, 'enum_variants': { kind: 'vec', element: { kind: 'string' } }, 'doc': { kind: 'option', inner: { kind: 'string' } }, 'lang': { kind: 'option', inner: { kind: 'string' } }, 'icon': { kind: 'option', inner: { kind: 'string' } }, 'subtype': { kind: 'option', inner: { kind: 'string' } } } } }, 'foreign_keys': { kind: 'vec', element: { kind: 'struct', fields: { 'columns': { kind: 'vec', element: { kind: 'string' } }, 'references_table': { kind: 'string' }, 'references_columns': { kind: 'vec', element: { kind: 'string' } } } } }, 'indices': { kind: 'vec', element: { kind: 'struct', fields: { 'name': { kind: 'string' }, 'columns': { kind: 'vec', element: { kind: 'struct', fields: { 'name': { kind: 'string' }, 'order': { kind: 'string' }, 'nulls': { kind: 'string' } } } }, 'unique': { kind: 'bool' }, 'where_clause': { kind: 'option', inner: { kind: 'string' } } } } }, 'source_file': { kind: 'option', inner: { kind: 'string' } }, 'source_line': { kind: 'option', inner: { kind: 'u32' } }, 'doc': { kind: 'option', inner: { kind: 'string' } }, 'icon': { kind: 'option', inner: { kind: 'string' } } } } } } }, error: null },
  list: { args: [{ kind: 'struct', fields: { 'table': { kind: 'string' }, 'filters': { kind: 'vec', element: { kind: 'struct', fields: { 'field': { kind: 'string' }, 'op': { kind: 'enum', variants: [{ name: 'Eq', fields: null }, { name: 'Ne', fields: null }, { name: 'Lt', fields: null }, { name: 'Lte', fields: null }, { name: 'Gt', fields: null }, { name: 'Gte', fields: null }, { name: 'Like', fields: null }, { name: 'ILike', fields: null }, { name: 'IsNull', fields: null }, { name: 'IsNotNull', fields: null }, { name: 'In', fields: null }, { name: 'JsonGet', fields: null }, { name: 'JsonGetText', fields: null }, { name: 'Contains', fields: null }, { name: 'KeyExists', fields: null }] }, 'value': { kind: 'enum', variants: [{ name: 'Null', fields: null }, { name: 'Bool', fields: { kind: 'bool' } }, { name: 'I16', fields: { kind: 'i16' } }, { name: 'I32', fields: { kind: 'i32' } }, { name: 'I64', fields: { kind: 'i64' } }, { name: 'F32', fields: { kind: 'f32' } }, { name: 'F64', fields: { kind: 'f64' } }, { name: 'String', fields: { kind: 'string' } }, { name: 'Bytes', fields: { kind: 'bytes' } }] }, 'values': { kind: 'vec', element: { kind: 'enum', variants: [{ name: 'Null', fields: null }, { name: 'Bool', fields: { kind: 'bool' } }, { name: 'I16', fields: { kind: 'i16' } }, { name: 'I32', fields: { kind: 'i32' } }, { name: 'I64', fields: { kind: 'i64' } }, { name: 'F32', fields: { kind: 'f32' } }, { name: 'F64', fields: { kind: 'f64' } }, { name: 'String', fields: { kind: 'string' } }, { name: 'Bytes', fields: { kind: 'bytes' } }] } } } } }, 'sort': { kind: 'vec', element: { kind: 'struct', fields: { 'field': { kind: 'string' }, 'dir': { kind: 'enum', variants: [{ name: 'Asc', fields: null }, { name: 'Desc', fields: null }] } } } }, 'limit': { kind: 'option', inner: { kind: 'u32' } }, 'offset': { kind: 'option', inner: { kind: 'u32' } }, 'select': { kind: 'vec', element: { kind: 'string' } } } }], returns: { kind: 'struct', fields: { 'rows': { kind: 'vec', element: { kind: 'struct', fields: { 'fields': { kind: 'vec', element: { kind: 'struct', fields: { 'name': { kind: 'string' }, 'value': { kind: 'enum', variants: [{ name: 'Null', fields: null }, { name: 'Bool', fields: { kind: 'bool' } }, { name: 'I16', fields: { kind: 'i16' } }, { name: 'I32', fields: { kind: 'i32' } }, { name: 'I64', fields: { kind: 'i64' } }, { name: 'F32', fields: { kind: 'f32' } }, { name: 'F64', fields: { kind: 'f64' } }, { name: 'String', fields: { kind: 'string' } }, { name: 'Bytes', fields: { kind: 'bytes' } }] } } } } } } }, 'total': { kind: 'option', inner: { kind: 'u64' } } } }, error: { kind: 'enum', variants: [{ name: 'ConnectionFailed', fields: { kind: 'string' } }, { name: 'MigrationFailed', fields: { kind: 'struct', fields: { 'message': { kind: 'string' }, 'sql': { kind: 'option', inner: { kind: 'string' } }, 'position': { kind: 'option', inner: { kind: 'u32' } }, 'hint': { kind: 'option', inner: { kind: 'string' } }, 'detail': { kind: 'option', inner: { kind: 'string' } }, 'caller': { kind: 'option', inner: { kind: 'string' } } } } }, { name: 'InvalidRequest', fields: { kind: 'string' } }, { name: 'UnknownTable', fields: { kind: 'string' } }, { name: 'UnknownColumn', fields: { kind: 'string' } }, { name: 'QueryError', fields: { kind: 'string' } }] } },
  get: { args: [{ kind: 'struct', fields: { 'table': { kind: 'string' }, 'pk': { kind: 'enum', variants: [{ name: 'Null', fields: null }, { name: 'Bool', fields: { kind: 'bool' } }, { name: 'I16', fields: { kind: 'i16' } }, { name: 'I32', fields: { kind: 'i32' } }, { name: 'I64', fields: { kind: 'i64' } }, { name: 'F32', fields: { kind: 'f32' } }, { name: 'F64', fields: { kind: 'f64' } }, { name: 'String', fields: { kind: 'string' } }, { name: 'Bytes', fields: { kind: 'bytes' } }] } } }], returns: { kind: 'option', inner: { kind: 'struct', fields: { 'fields': { kind: 'vec', element: { kind: 'struct', fields: { 'name': { kind: 'string' }, 'value': { kind: 'enum', variants: [{ name: 'Null', fields: null }, { name: 'Bool', fields: { kind: 'bool' } }, { name: 'I16', fields: { kind: 'i16' } }, { name: 'I32', fields: { kind: 'i32' } }, { name: 'I64', fields: { kind: 'i64' } }, { name: 'F32', fields: { kind: 'f32' } }, { name: 'F64', fields: { kind: 'f64' } }, { name: 'String', fields: { kind: 'string' } }, { name: 'Bytes', fields: { kind: 'bytes' } }] } } } } } } }, error: { kind: 'enum', variants: [{ name: 'ConnectionFailed', fields: { kind: 'string' } }, { name: 'MigrationFailed', fields: { kind: 'struct', fields: { 'message': { kind: 'string' }, 'sql': { kind: 'option', inner: { kind: 'string' } }, 'position': { kind: 'option', inner: { kind: 'u32' } }, 'hint': { kind: 'option', inner: { kind: 'string' } }, 'detail': { kind: 'option', inner: { kind: 'string' } }, 'caller': { kind: 'option', inner: { kind: 'string' } } } } }, { name: 'InvalidRequest', fields: { kind: 'string' } }, { name: 'UnknownTable', fields: { kind: 'string' } }, { name: 'UnknownColumn', fields: { kind: 'string' } }, { name: 'QueryError', fields: { kind: 'string' } }] } },
  create: { args: [{ kind: 'struct', fields: { 'table': { kind: 'string' }, 'data': { kind: 'struct', fields: { 'fields': { kind: 'vec', element: { kind: 'struct', fields: { 'name': { kind: 'string' }, 'value': { kind: 'enum', variants: [{ name: 'Null', fields: null }, { name: 'Bool', fields: { kind: 'bool' } }, { name: 'I16', fields: { kind: 'i16' } }, { name: 'I32', fields: { kind: 'i32' } }, { name: 'I64', fields: { kind: 'i64' } }, { name: 'F32', fields: { kind: 'f32' } }, { name: 'F64', fields: { kind: 'f64' } }, { name: 'String', fields: { kind: 'string' } }, { name: 'Bytes', fields: { kind: 'bytes' } }] } } } } } } } }], returns: { kind: 'struct', fields: { 'fields': { kind: 'vec', element: { kind: 'struct', fields: { 'name': { kind: 'string' }, 'value': { kind: 'enum', variants: [{ name: 'Null', fields: null }, { name: 'Bool', fields: { kind: 'bool' } }, { name: 'I16', fields: { kind: 'i16' } }, { name: 'I32', fields: { kind: 'i32' } }, { name: 'I64', fields: { kind: 'i64' } }, { name: 'F32', fields: { kind: 'f32' } }, { name: 'F64', fields: { kind: 'f64' } }, { name: 'String', fields: { kind: 'string' } }, { name: 'Bytes', fields: { kind: 'bytes' } }] } } } } } }, error: { kind: 'enum', variants: [{ name: 'ConnectionFailed', fields: { kind: 'string' } }, { name: 'MigrationFailed', fields: { kind: 'struct', fields: { 'message': { kind: 'string' }, 'sql': { kind: 'option', inner: { kind: 'string' } }, 'position': { kind: 'option', inner: { kind: 'u32' } }, 'hint': { kind: 'option', inner: { kind: 'string' } }, 'detail': { kind: 'option', inner: { kind: 'string' } }, 'caller': { kind: 'option', inner: { kind: 'string' } } } } }, { name: 'InvalidRequest', fields: { kind: 'string' } }, { name: 'UnknownTable', fields: { kind: 'string' } }, { name: 'UnknownColumn', fields: { kind: 'string' } }, { name: 'QueryError', fields: { kind: 'string' } }] } },
  update: { args: [{ kind: 'struct', fields: { 'table': { kind: 'string' }, 'pk': { kind: 'enum', variants: [{ name: 'Null', fields: null }, { name: 'Bool', fields: { kind: 'bool' } }, { name: 'I16', fields: { kind: 'i16' } }, { name: 'I32', fields: { kind: 'i32' } }, { name: 'I64', fields: { kind: 'i64' } }, { name: 'F32', fields: { kind: 'f32' } }, { name: 'F64', fields: { kind: 'f64' } }, { name: 'String', fields: { kind: 'string' } }, { name: 'Bytes', fields: { kind: 'bytes' } }] }, 'data': { kind: 'struct', fields: { 'fields': { kind: 'vec', element: { kind: 'struct', fields: { 'name': { kind: 'string' }, 'value': { kind: 'enum', variants: [{ name: 'Null', fields: null }, { name: 'Bool', fields: { kind: 'bool' } }, { name: 'I16', fields: { kind: 'i16' } }, { name: 'I32', fields: { kind: 'i32' } }, { name: 'I64', fields: { kind: 'i64' } }, { name: 'F32', fields: { kind: 'f32' } }, { name: 'F64', fields: { kind: 'f64' } }, { name: 'String', fields: { kind: 'string' } }, { name: 'Bytes', fields: { kind: 'bytes' } }] } } } } } } } }], returns: { kind: 'struct', fields: { 'fields': { kind: 'vec', element: { kind: 'struct', fields: { 'name': { kind: 'string' }, 'value': { kind: 'enum', variants: [{ name: 'Null', fields: null }, { name: 'Bool', fields: { kind: 'bool' } }, { name: 'I16', fields: { kind: 'i16' } }, { name: 'I32', fields: { kind: 'i32' } }, { name: 'I64', fields: { kind: 'i64' } }, { name: 'F32', fields: { kind: 'f32' } }, { name: 'F64', fields: { kind: 'f64' } }, { name: 'String', fields: { kind: 'string' } }, { name: 'Bytes', fields: { kind: 'bytes' } }] } } } } } }, error: { kind: 'enum', variants: [{ name: 'ConnectionFailed', fields: { kind: 'string' } }, { name: 'MigrationFailed', fields: { kind: 'struct', fields: { 'message': { kind: 'string' }, 'sql': { kind: 'option', inner: { kind: 'string' } }, 'position': { kind: 'option', inner: { kind: 'u32' } }, 'hint': { kind: 'option', inner: { kind: 'string' } }, 'detail': { kind: 'option', inner: { kind: 'string' } }, 'caller': { kind: 'option', inner: { kind: 'string' } } } } }, { name: 'InvalidRequest', fields: { kind: 'string' } }, { name: 'UnknownTable', fields: { kind: 'string' } }, { name: 'UnknownColumn', fields: { kind: 'string' } }, { name: 'QueryError', fields: { kind: 'string' } }] } },
  delete: { args: [{ kind: 'struct', fields: { 'table': { kind: 'string' }, 'pk': { kind: 'enum', variants: [{ name: 'Null', fields: null }, { name: 'Bool', fields: { kind: 'bool' } }, { name: 'I16', fields: { kind: 'i16' } }, { name: 'I32', fields: { kind: 'i32' } }, { name: 'I64', fields: { kind: 'i64' } }, { name: 'F32', fields: { kind: 'f32' } }, { name: 'F64', fields: { kind: 'f64' } }, { name: 'String', fields: { kind: 'string' } }, { name: 'Bytes', fields: { kind: 'bytes' } }] } } }], returns: { kind: 'u64' }, error: { kind: 'enum', variants: [{ name: 'ConnectionFailed', fields: { kind: 'string' } }, { name: 'MigrationFailed', fields: { kind: 'struct', fields: { 'message': { kind: 'string' }, 'sql': { kind: 'option', inner: { kind: 'string' } }, 'position': { kind: 'option', inner: { kind: 'u32' } }, 'hint': { kind: 'option', inner: { kind: 'string' } }, 'detail': { kind: 'option', inner: { kind: 'string' } }, 'caller': { kind: 'option', inner: { kind: 'string' } } } } }, { name: 'InvalidRequest', fields: { kind: 'string' } }, { name: 'UnknownTable', fields: { kind: 'string' } }, { name: 'UnknownColumn', fields: { kind: 'string' } }, { name: 'QueryError', fields: { kind: 'string' } }] } },
};

